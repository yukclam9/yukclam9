1
00:00:00 --> 00:00:00



2
00:00:00 --> 00:00:02
ANNOUNCER: Open content is
provided under creative

3
00:00:02 --> 00:00:03
commons license.


4
00:00:03 --> 00:00:06
Your support will help MIT
OpenCourseWare continue to

5
00:00:06 --> 00:00:10
offer high-quality educational
resources for free.

6
00:00:10 --> 00:00:13
To make a donation, or view
additional materials from

7
00:00:13 --> 00:00:17
hundreds of MIT courses,
visit MIT OpenCourseWare

8
00:00:17 --> 00:00:18
at ocw.mit.edu.


9
00:00:19 --> 00:00:23
PROFESSOR ERIC GRIMSON: As I've
done in the previous lectures,

10
00:00:23 --> 00:00:26
let me set the stage for what
we've been doing, so we can

11
00:00:26 --> 00:00:30
use that to talk about what
we're going to do today.

12
00:00:30 --> 00:00:35
So far, we have the
following in our language.

13
00:00:35 --> 00:00:41
Right, we have assignment.


14
00:00:41 --> 00:00:46
We have conditionals.


15
00:00:46 --> 00:00:47
We have input/output.


16
00:00:47 --> 00:00:55
And we have looping constructs.


17
00:00:55 --> 00:01:00
These are things like
FOR and WHILE loops.

18
00:01:00 --> 00:01:04
And of course we've got
some data to go with that.

19
00:01:04 --> 00:01:07
One of the things we said last
time was, with that set of

20
00:01:07 --> 00:01:11
things, the ability to give
values-- sorry, to give names

21
00:01:11 --> 00:01:14
to values-- the ability to make
decisions, the ability to loop

22
00:01:14 --> 00:01:17
as a function of that, the
ability get things in and out,

23
00:01:17 --> 00:01:21
we said that that actually gave
us a language we said

24
00:01:21 --> 00:01:26
was Turing-complete.


25
00:01:26 --> 00:01:29
And that meant, in English,
that this was enough

26
00:01:29 --> 00:01:32
to write any program.


27
00:01:32 --> 00:01:34
Now that's a slight lie-- or
actually in these days of

28
00:01:34 --> 00:01:39
political debates, a slight
misspeaking, a wonderful word--

29
00:01:39 --> 00:01:40
it is technically correct.


30
00:01:40 --> 00:01:43
It is enough to allow us to
write any program, but it's

31
00:01:43 --> 00:01:47
not enough to allow us to
easily write any program.

32
00:01:47 --> 00:01:50
And so I joked, badly, I'll
agree, at the end of last

33
00:01:50 --> 00:01:52
lecture, that we can just stop
now, go straight to the final

34
00:01:52 --> 00:01:54
exam, because this is
all you need to know.

35
00:01:54 --> 00:01:58
The point is, yes it's enough
to start with, but we want to

36
00:01:58 --> 00:02:00
add things to this that let
us problem solve well.

37
00:02:00 --> 00:02:03
And one of the things to think
about is, even though I've got

38
00:02:03 --> 00:02:06
all of that, let's think about
what I could do, if I wanted

39
00:02:06 --> 00:02:09
to write a piece of code.


40
00:02:09 --> 00:02:11
Right now, you've got to
write it in one file.

41
00:02:11 --> 00:02:14
It's a long sequence of
instructions, it starts at the

42
00:02:14 --> 00:02:17
beginning, walks through, may
jump around a little bit, but

43
00:02:17 --> 00:02:19
eventually comes
down at the end.

44
00:02:19 --> 00:02:21
It's okay for the things
you're doing for the

45
00:02:21 --> 00:02:23
early problem sets.


46
00:02:23 --> 00:02:24
Ten lines of code.


47
00:02:24 --> 00:02:25
Twenty lines of code.


48
00:02:25 --> 00:02:28
Imagine instead, you're writing
code that's a hundred thousand

49
00:02:28 --> 00:02:31
lines, a million
lines, of code.

50
00:02:31 --> 00:02:34
You don't want to write
it in this form.

51
00:02:34 --> 00:02:35
All right, and the reason
you don't want to do

52
00:02:35 --> 00:02:37
that is, well, several.


53
00:02:37 --> 00:02:39
First of all, it's really hard
to figure out where everything

54
00:02:39 --> 00:02:40
is, where everything goes,
making sure I'm in

55
00:02:40 --> 00:02:42
the right place.


56
00:02:42 --> 00:02:45
To use an ancient expression
from the 1970's, which only

57
00:02:45 --> 00:02:48
John and I will appreciate,
it's really hard to grok what

58
00:02:48 --> 00:02:50
that code is doing, to
understand what it's

59
00:02:50 --> 00:02:52
trying to make happen.


60
00:02:52 --> 00:02:55
And the reason that that's the
case is, what we don't have,

61
00:02:55 --> 00:03:00
are two important things.


62
00:03:00 --> 00:03:12
We don't have decomposition,
and we don't have abstraction.

63
00:03:12 --> 00:03:13
And that's what we're
going to add today.

64
00:03:13 --> 00:03:14
So what does that mean?


65
00:03:14 --> 00:03:15
Those are fancy terms.


66
00:03:15 --> 00:03:20
Decomposition is a way
of putting structure

67
00:03:20 --> 00:03:20
onto the code.


68
00:03:20 --> 00:03:23
It's a way of breaking the
code up into modules.

69
00:03:23 --> 00:03:25
Modules that makes
sense on their own.

70
00:03:25 --> 00:03:28
Modules that we can reuse
in multiple places.

71
00:03:28 --> 00:03:31
Modules that, if you
like, isolate components

72
00:03:31 --> 00:03:32
of the process.


73
00:03:32 --> 00:03:35
And abstraction is related to
that, abstraction is going

74
00:03:35 --> 00:03:37
to let us suppress details.


75
00:03:37 --> 00:03:42
It's going to let us bury away
the specifics of something, and

76
00:03:42 --> 00:03:44
treat that computation
like a black box.

77
00:03:44 --> 00:03:47
And by black box, I mean,
literally behaves like a

78
00:03:47 --> 00:03:49
mysterious little black box.


79
00:03:49 --> 00:03:52
You put some inputs in, it has
a contract that says if you put

80
00:03:52 --> 00:03:55
the right kind of inputs in
you'll get a specific output

81
00:03:55 --> 00:03:57
coming out, but you don't
have to know what's

82
00:03:57 --> 00:03:58
inside of that box.


83
00:03:58 --> 00:04:01
And that abstraction
is really important.

84
00:04:01 --> 00:04:04
Again, imagine if I'm a
writing a piece of code.

85
00:04:04 --> 00:04:07
I want to just use it, I
shouldn't have to worry about

86
00:04:07 --> 00:04:09
what variables I use inside of
it, I have shouldn't have to

87
00:04:09 --> 00:04:11
worry about where that is in
the code, I should be able

88
00:04:11 --> 00:04:13
to just abstract it away.


89
00:04:13 --> 00:04:16
And that's what we want to add
today, are those two things.

90
00:04:16 --> 00:04:19
Now, our mechanism for doing
that-- or at least one

91
00:04:19 --> 00:04:23
mechanism, I shouldn't say the
only one-- one mechanism for

92
00:04:23 --> 00:04:30
doing that is going to be to
add functions to our language.

93
00:04:30 --> 00:04:35
Now, the point of a function is
that it's going to provide both

94
00:04:35 --> 00:04:37
of these things, so the first
thing it's going to do is, it's

95
00:04:37 --> 00:04:44
going to let us break
up into modules.

96
00:04:44 --> 00:04:51
Second thing they're going to
do is let us suppress detail.

97
00:04:51 --> 00:04:53
And in essence what that does
is, the functions, and we're

98
00:04:53 --> 00:04:54
going to look at a bunch of
examples in a second, these

99
00:04:54 --> 00:04:58
functions are going to give us
a way to, in some or in one

100
00:04:58 --> 00:05:00
way of thinking about it is
to create new primitives.

101
00:05:00 --> 00:05:10
And I'm going to put those in
quotes, it's a generalization.

102
00:05:10 --> 00:05:12
What do I mean by that?


103
00:05:12 --> 00:05:15
The idea of a function is, that
I'm going to capture a common

104
00:05:15 --> 00:05:17
pattern of computation.


105
00:05:17 --> 00:05:18
Computing square root.


106
00:05:18 --> 00:05:21
I'm going to capture it in a
piece of code, I'm going to be

107
00:05:21 --> 00:05:24
able to refer to it by a name,
and I'm going to suppress the

108
00:05:24 --> 00:05:26
details, meaning inside of
that computation, you don't

109
00:05:26 --> 00:05:27
need to know what it does.


110
00:05:27 --> 00:05:29
You just need to know, if I
give it the right kind of

111
00:05:29 --> 00:05:31
input, it'll give me back an
input that satisfies the

112
00:05:31 --> 00:05:34
contract that I set up.


113
00:05:34 --> 00:05:37
And that in essence says, I've
just created the equivalent

114
00:05:37 --> 00:05:38
of a new primitive.


115
00:05:38 --> 00:05:41
Same way that I have
multiplication or division as a

116
00:05:41 --> 00:05:44
primitive, functions are going
to give me, or somebody else

117
00:05:44 --> 00:05:46
who wrote them for me as part
of a library, a new primitive

118
00:05:46 --> 00:05:48
that I'm going to
be able to use.

119
00:05:48 --> 00:05:50
And that gives me a lot of
power in terms of what I want

120
00:05:50 --> 00:05:52
to have inside of the language.


121
00:05:52 --> 00:05:55
OK.


122
00:05:55 --> 00:05:58
So, let's look at an example.


123
00:05:58 --> 00:06:01
To try to see what we're
going to do with this.

124
00:06:01 --> 00:06:03
Before I do that though, let me
try and give you an analogy to

125
00:06:03 --> 00:06:06
keep this in mind of why we
want to basically build these

126
00:06:06 --> 00:06:08
abstractions and what we
need in order to have

127
00:06:08 --> 00:06:10
them work together.


128
00:06:10 --> 00:06:13
So here's the supposed
to say silly analogy.

129
00:06:13 --> 00:06:15
You can tell my jokes
are always bad.

130
00:06:15 --> 00:06:17
John's are much better, by the
way, which is why Thursday will

131
00:06:17 --> 00:06:19
be a much better lay--
a better lecture.

132
00:06:19 --> 00:06:20
But here's the example.


133
00:06:20 --> 00:06:24
You've been hired by PBS to
produce a nice thirteen-hour

134
00:06:24 --> 00:06:28
documentary, or drama,
that's going to run.

135
00:06:28 --> 00:06:32
And, you know, you start by
saying, OK, thirteen hours, I'm

136
00:06:32 --> 00:06:34
going to break it up into
thirteen different chunks.

137
00:06:34 --> 00:06:37
I'm going to assign each
chunk to a different writer.

138
00:06:37 --> 00:06:39
And they're going to go off
and write that element,

139
00:06:39 --> 00:06:41
that hour's worth of stuff.


140
00:06:41 --> 00:06:45
You can imagine what you get:
each hours worth of drama, if

141
00:06:45 --> 00:06:49
you like, may be great, but it
may have absolutely nothing to

142
00:06:49 --> 00:06:51
do with the other twelve hours.


143
00:06:51 --> 00:06:54
And unless, you know, you've
been hired to do Pirandello's

144
00:06:54 --> 00:06:57
Six Characters In Search Of An
Author, this is not a great

145
00:06:57 --> 00:06:58
thing, because you get
something that is

146
00:06:58 --> 00:07:00
really confusing.


147
00:07:00 --> 00:07:01
Now, what's the point
of the analogy?

148
00:07:01 --> 00:07:03
What do I need for
those writers to all

149
00:07:03 --> 00:07:04
interact together?


150
00:07:04 --> 00:07:06
I need a specification.


151
00:07:06 --> 00:07:10
I need a contract that says,
here's what I want in terms of

152
00:07:10 --> 00:07:12
things that you're going to
take as input, to begin your

153
00:07:12 --> 00:07:15
part of the drama, here's what
you're going to produce at the

154
00:07:15 --> 00:07:20
output, and the details of what
they do inside are up to them.

155
00:07:20 --> 00:07:22
An idea of abstraction, that
idea of specification, is

156
00:07:22 --> 00:07:25
exactly what we want to use
inside of our functions.

157
00:07:25 --> 00:07:27
We won't make you write dramas
like Pirandello, but we're

158
00:07:27 --> 00:07:29
going to try make you at
least write good code.

159
00:07:29 --> 00:07:30
And that's we're
going to try and do.

160
00:07:30 --> 00:07:31
All right.


161
00:07:31 --> 00:07:33
Let's set the stage for it.


162
00:07:33 --> 00:07:38
Up on the screen, I've got-- I
commented it out, but I've got

163
00:07:38 --> 00:07:41
a piece of code that you've
seen before, right up here.

164
00:07:41 --> 00:07:42
OK?


165
00:07:42 --> 00:07:43
What is that?


166
00:07:43 --> 00:07:45
It's the piece of code we wrote
for computing square roots,

167
00:07:45 --> 00:07:48
square roots of actually
perfect squares.

168
00:07:48 --> 00:07:48
[UNINTELLIGIBLE]


169
00:07:48 --> 00:07:52
Just to remind you what it
does, we bound x to some value,

170
00:07:52 --> 00:07:56
we set up an initial variable
called ANS or answer, and then

171
00:07:56 --> 00:07:57
we run through a little loop.


172
00:07:57 --> 00:07:59
All right, we're-- well
actually, I should say that

173
00:07:59 --> 00:08:02
better, we first check to see,
is x greater than or equal to

174
00:08:02 --> 00:08:05
zero, if it's not, then we come
down here and we print

175
00:08:05 --> 00:08:07
something out, otherwise we run
through a little loop to get

176
00:08:07 --> 00:08:10
the answer, and then we check
it and we spit something out.

177
00:08:10 --> 00:08:13
It does the computation,
that's fine.

178
00:08:13 --> 00:08:16
Suppose I want to compute
square roots a lot of places

179
00:08:16 --> 00:08:18
in a big chunk of code.


180
00:08:18 --> 00:08:21
Right now, I have to take that
piece of code and replicate

181
00:08:21 --> 00:08:24
it everywhere I want
in my larger file.

182
00:08:24 --> 00:08:27
And I've got to worry about, is
somebody else using ANS,

183
00:08:27 --> 00:08:30
answer, as a variable, in which
case I've got to be

184
00:08:30 --> 00:08:30
really careful.


185
00:08:30 --> 00:08:32
Is somebody else using
x as a variable?

186
00:08:32 --> 00:08:35
I've got to deal with a
lot of those details.

187
00:08:35 --> 00:08:36
I want to abstract that.


188
00:08:36 --> 00:08:40
And the abstraction
you see, right here.

189
00:08:40 --> 00:08:42
I'm going to highlight it for
a second so you can see it.

190
00:08:42 --> 00:08:44
I want you to look at it
on the handout as well.

191
00:08:44 --> 00:08:48
This is the creation
of a function.

192
00:08:48 --> 00:08:51
And I want to describe both the
syntax, what we're doing, and

193
00:08:51 --> 00:08:54
then the semantics of how do we
use it and what does that mean.

194
00:08:54 --> 00:08:56
So.


195
00:08:56 --> 00:09:01
Here's the syntax
of the function.

196
00:09:01 --> 00:09:04
First of all, we have
a keyword. def.

197
00:09:04 --> 00:09:07
Definition or define, depending
on which sort of piece of

198
00:09:07 --> 00:09:08
history you come from.


199
00:09:08 --> 00:09:10
This is a keyword to Python
that says, when it reads this

200
00:09:10 --> 00:09:13
in the file, it says, I'm
creating a definition.

201
00:09:13 --> 00:09:15
I'm creating a function.


202
00:09:15 --> 00:09:17
And that's follow-- so this
is, let me say this is a

203
00:09:17 --> 00:09:24
keyboard-- that is followed
immediately by a name.

204
00:09:24 --> 00:09:25
And this equates to that.


205
00:09:25 --> 00:09:28
In this case, sqrt,
square root.

206
00:09:28 --> 00:09:30
I'm saying, this is the
name I'm going to give

207
00:09:30 --> 00:09:31
to this function.


208
00:09:31 --> 00:09:33
This is the name to which I'm
going to refer when I want

209
00:09:33 --> 00:09:34
to use this function.


210
00:09:34 --> 00:09:35
All right?


211
00:09:35 --> 00:09:41
And notice, immediately after
that name, we have an open and

212
00:09:41 --> 00:09:45
close paren with another
variable name inside of that.

213
00:09:45 --> 00:09:56
And this defines formal
parameters of this function.

214
00:09:56 --> 00:09:56
Yup.


215
00:09:56 --> 00:09:58
PROFESSOR JOHN
GUTTAG: [INAUDIBLE]

216
00:09:58 --> 00:09:59
PROFESSOR ERIC GRIMSON: It
does indeed, thank you.

217
00:09:59 --> 00:10:02
This is me being a Scheme
hacker, not a Python hacker.

218
00:10:02 --> 00:10:04
Yes, def has to be lowercase
or won't recognize it.

219
00:10:04 --> 00:10:06
Thank you, John.


220
00:10:06 --> 00:10:08
OK. def's the keyword.


221
00:10:08 --> 00:10:11
I'm creating a function. sqrt--
again, I'm being careful about

222
00:10:11 --> 00:10:13
case-sensitive, I'm using all
lowercase here, followed by an

223
00:10:13 --> 00:10:15
open paren, and I said,
formal parameters.

224
00:10:15 --> 00:10:17
We'll see there could be
more than one there.

225
00:10:17 --> 00:10:19
We're going to come back to
what they mean in a second, but

226
00:10:19 --> 00:10:22
for now, think of them as, or
think of x, in this case,

227
00:10:22 --> 00:10:23
as the place holder.


228
00:10:23 --> 00:10:27
This place holder is saying, if
you give me a value for x,

229
00:10:27 --> 00:10:30
inside the body of this
function I'm going to use that

230
00:10:30 --> 00:10:32
value everywhere I see x.


231
00:10:32 --> 00:10:32
Question.


232
00:10:32 --> 00:10:36
STUDENT: [INAUDIBLE]


233
00:10:36 --> 00:10:36
PROFESSOR ERIC GRIMSON: Ah,
we're going to come back

234
00:10:36 --> 00:10:37
to this in a second.


235
00:10:37 --> 00:10:39
But the question was, do
I always need an input?

236
00:10:39 --> 00:10:42
I can have functions with no
parameters, that's fine, I will

237
00:10:42 --> 00:10:45
still need the open and close
paren there to identify

238
00:10:45 --> 00:10:46
that I have no parameters.


239
00:10:46 --> 00:10:48
We're going to see an
example in a second.

240
00:10:48 --> 00:10:49
Good question.


241
00:10:49 --> 00:10:51
Actually, I've got to get rid
of this candy, so since it was

242
00:10:51 --> 00:10:54
a good question, here you go.


243
00:10:54 --> 00:10:56
Nice catch.


244
00:10:56 --> 00:10:57
Almost.


245
00:10:57 --> 00:10:58
Sorry.


246
00:10:58 --> 00:10:59
OK.


247
00:10:59 --> 00:11:00
No, I'm not.


248
00:11:00 --> 00:11:00
I'm sorry.


249
00:11:00 --> 00:11:02
I thought you had it, and then
I've got the wrong glasses on

250
00:11:02 --> 00:11:04
and I realized you didn't, so I
will, ah come back

251
00:11:04 --> 00:11:05
to that later.


252
00:11:05 --> 00:11:06
What are we doing here?


253
00:11:06 --> 00:11:08
We got definition, we got
name, we got a set of

254
00:11:08 --> 00:11:09
formal parameters.


255
00:11:09 --> 00:11:10
Right.


256
00:11:10 --> 00:11:13
If you look at the rest of that
code, gee, it looks a lot

257
00:11:13 --> 00:11:14
like what I had elsewhere.


258
00:11:14 --> 00:11:16
Of what I had outside
of it, right?

259
00:11:16 --> 00:11:18
It's running through a
similar set of loops.

260
00:11:18 --> 00:11:21
So in some sets, as long as
x has the value I want, it

261
00:11:21 --> 00:11:22
ought to do the right thing.


262
00:11:22 --> 00:11:24
However, there's a couple of
other changes there that

263
00:11:24 --> 00:11:26
we want to highlight.


264
00:11:26 --> 00:11:31
In particular, notice-- let me
highlight it for you, if I can

265
00:11:31 --> 00:11:34
find it with the wrong glasses
on-- we've got these

266
00:11:34 --> 00:11:37
return commands.


267
00:11:37 --> 00:11:42
So return is another keyword.


268
00:11:42 --> 00:11:48
And it basically says, when
you get to this point in

269
00:11:48 --> 00:11:52
the computation, stop
the computation.

270
00:11:52 --> 00:11:56
Literally, return the control
from this function, and take

271
00:11:56 --> 00:11:59
the value of the next
expression, and return that

272
00:11:59 --> 00:12:02
as the value of the
whole computation.

273
00:12:02 --> 00:12:04
Now, the one that we're most
interested in is the one where,

274
00:12:04 --> 00:12:07
in fact, it gets out ANS, so
you see down here in the code,

275
00:12:07 --> 00:12:11
there's a spot where it's going
to return the value of ANS,

276
00:12:11 --> 00:12:12
which is what we want, right?


277
00:12:12 --> 00:12:15
That's the thing that holds the
value that we intended to have.

278
00:12:15 --> 00:12:17
But there's another couple of
places in that code where it's

279
00:12:17 --> 00:12:20
got this funky-looking thing,
return none, and notice

280
00:12:20 --> 00:12:22
none's in a different color.


281
00:12:22 --> 00:12:34
None is a special value, and it
has the following slightly-odd

282
00:12:34 --> 00:12:39
behavior: it is a value, we can
return it-- God bless-- but

283
00:12:39 --> 00:12:42
what none says is, there is no
value coming back from

284
00:12:42 --> 00:12:44
this computation.


285
00:12:44 --> 00:12:46
So when it is returned, and
we'll see this in a second,

286
00:12:46 --> 00:12:49
to the interpreter,
it doesn't print.

287
00:12:49 --> 00:12:49
OK.


288
00:12:49 --> 00:12:51
It simply doesn't
print anything.

289
00:12:51 --> 00:12:53
Nonetheless, it is actually a
value and we can use it, for

290
00:12:53 --> 00:12:55
example, to do comparisons.


291
00:12:55 --> 00:12:58
If we want to know, did this
function return a value or not,

292
00:12:58 --> 00:13:01
rather than reserving, say, -1
or some other special thing

293
00:13:01 --> 00:13:03
which you might want to use
some other ways, it literally

294
00:13:03 --> 00:13:06
returns this very special value
that says, there is no actual

295
00:13:06 --> 00:13:09
value return from
this computation.

296
00:13:09 --> 00:13:11
OK.


297
00:13:11 --> 00:13:15
Note, by the way, if I chase
through each possible path,

298
00:13:15 --> 00:13:18
like there's some IFs in here,
there's some places to go, at

299
00:13:18 --> 00:13:21
least in this piece of code,
every possible path through

300
00:13:21 --> 00:13:23
this code ends in a return.


301
00:13:23 --> 00:13:25
And that's a good programming
discipline, to make

302
00:13:25 --> 00:13:27
sure that happens.


303
00:13:27 --> 00:13:28
There's an exception, which
we'll see in a second, but I'll

304
00:13:28 --> 00:13:32
highlight, which is, if we get
to the end of the procedure,

305
00:13:32 --> 00:13:34
there's sort of an
implicit return there.

306
00:13:34 --> 00:13:36
In fact, a return of
none, in that case.

307
00:13:36 --> 00:13:36
It comes out of it.


308
00:13:36 --> 00:13:38
But if I look at this, right?


309
00:13:38 --> 00:13:41
If I come into this code, I'm
going to check this branch

310
00:13:41 --> 00:13:43
first, if it's not true, ah,
there's a return at the

311
00:13:43 --> 00:13:44
end of that branch.


312
00:13:44 --> 00:13:48
If it is true, I do that, and
then I've got a second test.

313
00:13:48 --> 00:13:50
If it's true, I return,
otherwise a return.

314
00:13:50 --> 00:13:53
So there's a return branch
on every possible path

315
00:13:53 --> 00:13:54
through the code.


316
00:13:54 --> 00:13:55
And that's valuable, it's
something you want to think

317
00:13:55 --> 00:13:59
about as your right your own.


318
00:13:59 --> 00:14:00
OK.


319
00:14:00 --> 00:14:04
What do I do to use
this, in particular?

320
00:14:04 --> 00:14:07
How do I invoke this?


321
00:14:07 --> 00:14:14
OK, so I'm going to invoke
a function by passing in

322
00:14:14 --> 00:14:24
values for the parameters.


323
00:14:24 --> 00:14:27
And in this case, that
literally means typing

324
00:14:27 --> 00:14:34
sqrt, with some value
inside the parens.

325
00:14:34 --> 00:14:36
OK.


326
00:14:36 --> 00:14:38
Now, let's just try this
out to see what happens.

327
00:14:38 --> 00:14:42
I'm going to make sure I've got
it there, so if I type, for

328
00:14:42 --> 00:14:50
example, sqrt of 16, ah-ha!


329
00:14:50 --> 00:14:51
What did it do?


330
00:14:51 --> 00:14:53
Well, let's talk
about what it did.

331
00:14:53 --> 00:14:58
What this invocation does, is
the following: it binds, and

332
00:14:58 --> 00:15:01
I'm going to say this
specifically for this example,

333
00:15:01 --> 00:15:06
rather than general,
it binds x to 16.

334
00:15:06 --> 00:15:09
Just as you would have done
with an assignment statement

335
00:15:09 --> 00:15:10
up in the top level thing.


336
00:15:10 --> 00:15:16
But this binding is local.


337
00:15:16 --> 00:15:19
Meaning it only holds
within the confines of the

338
00:15:19 --> 00:15:22
code of this procedure.


339
00:15:22 --> 00:15:24
Relative to that, think of that
as creating what we, I'm going

340
00:15:24 --> 00:15:25
to call a new environment.


341
00:15:25 --> 00:15:28
Relative to that, it does all
the other execution we would

342
00:15:28 --> 00:15:31
do, including, notice the first
instruction there is to the

343
00:15:31 --> 00:15:32
set up a binding for ANS.


344
00:15:32 --> 00:15:42
So answer, or ANS, is
also bound only locally.

345
00:15:42 --> 00:15:44
Meaning, inside the confines
of this environment

346
00:15:44 --> 00:15:46
of this procedure.


347
00:15:46 --> 00:15:49
ANS starts off with a value of
0 and now we just run through

348
00:15:49 --> 00:15:50
that loop just like
we did before.

349
00:15:50 --> 00:15:53
Writing Increments it slowly,
checking to see if ANS squared

350
00:15:53 --> 00:15:56
is bigger than x, and when it
gets to that point, it checks

351
00:15:56 --> 00:15:58
to see, is it actually a
perfect square or not,

352
00:15:58 --> 00:15:58
and it returns it.


353
00:15:58 --> 00:16:02
And once it returns it, it
returns a value from that

354
00:16:02 --> 00:16:06
return, that in this case
is just printed out.

355
00:16:06 --> 00:16:07
All right.


356
00:16:07 --> 00:16:08
Now I want to say a couple
of things about these

357
00:16:08 --> 00:16:10
local bindings.


358
00:16:10 --> 00:16:12
I'm going to repeat this
a second time, because

359
00:16:12 --> 00:16:16
it's important.


360
00:16:16 --> 00:16:28
These local bindings do not
affect any global bindings.

361
00:16:28 --> 00:16:30
What does that mean?


362
00:16:30 --> 00:16:32
Let me show you a little
example, and then we'll

363
00:16:32 --> 00:16:34
come back to this.


364
00:16:34 --> 00:16:36
I've got a little
function here.

365
00:16:36 --> 00:16:40
See, I've defined f of x to be
a function that takes a value

366
00:16:40 --> 00:16:45
of x in, changes x to x+1, and
then just returns the value.

367
00:16:45 --> 00:16:45
OK.


368
00:16:45 --> 00:16:47
So it's just adding 1 to x.


369
00:16:47 --> 00:16:49
But I want you to see now
what happens if I use this.

370
00:16:49 --> 00:16:53
Let's bind x to the value of 3.


371
00:16:53 --> 00:16:56
It's creating a binding for x
in this global environment.

372
00:16:56 --> 00:16:57
This is what the
interpreter sees.

373
00:16:57 --> 00:16:58
All right?


374
00:16:58 --> 00:17:01
In fact, if I look at
x, its value is 3.

375
00:17:01 --> 00:17:08
Let's bind z eh let's bind z
to the-- if I could type it

376
00:17:08 --> 00:17:15
would help-- say, f of 3.


377
00:17:15 --> 00:17:16
OK?


378
00:17:16 --> 00:17:20
So the value is z is 4,
it's what I expect, right?

379
00:17:20 --> 00:17:22
Locally x got bound to 3, I
added 1 to it, whoop-dee-doo,

380
00:17:22 --> 00:17:24
I get back a 4.


381
00:17:24 --> 00:17:27
But what's the value of x?


382
00:17:27 --> 00:17:29
It's still 3.


383
00:17:29 --> 00:17:32
The way to think of this is,
again, I've got multiple

384
00:17:32 --> 00:17:35
scopes, or multiple frames, or
if we're going to come back to

385
00:17:35 --> 00:17:37
those terms, I'm going to use
the word environment, because

386
00:17:37 --> 00:17:39
I'm an old-time Lisp hacker,
multiple environments in

387
00:17:39 --> 00:17:40
which there are bindings.


388
00:17:40 --> 00:17:44
So let me spell this out in
just a little bit more detail.

389
00:17:44 --> 00:17:55
What this is saying
is the following.

390
00:17:55 --> 00:17:57
When I'm talking to the
interpreter, when I'm typing

391
00:17:57 --> 00:18:01
things in as I just did, to
that Python environment, I'm

392
00:18:01 --> 00:18:03
getting what I'm going to
call global bindings.

393
00:18:03 --> 00:18:15
I'm going to draw a
little chart here.

394
00:18:15 --> 00:18:17
Think of this as the, as the
world of the interpreter, in

395
00:18:17 --> 00:18:23
that I've got things like x
bound to the value of 3.

396
00:18:23 --> 00:18:30
When I call or invoke a
function, think of it as

397
00:18:30 --> 00:18:41
creating a local table.


398
00:18:41 --> 00:18:47
Inside that local table, I bind
the formal parameter, which

399
00:18:47 --> 00:18:51
is what I do I did 16
right to some value.

400
00:18:51 --> 00:18:55
This x only gets seen by sqrt.


401
00:18:55 --> 00:18:59
Inside of there, I can bind
other things, like ANS gets

402
00:18:59 --> 00:19:02
locally bound to 0, and then
it increments around and

403
00:19:02 --> 00:19:04
eventually we return
that value out.

404
00:19:04 --> 00:19:09
When I get to a return from
sqrt, some value is returned

405
00:19:09 --> 00:19:14
back to the interpreter,
and that table goes away.

406
00:19:14 --> 00:19:18
But that table does not affect
any bindings for other

407
00:19:18 --> 00:19:22
instances of the variable
like x for ANS.

408
00:19:22 --> 00:19:24
OK.


409
00:19:24 --> 00:19:25
Let's look at a couple
of examples, just to

410
00:19:25 --> 00:19:27
sort of stress that.


411
00:19:27 --> 00:19:33
And one of the things I
wanted to show is, OK.

412
00:19:33 --> 00:19:37
Again, I can now use a function
just as if it was a primitive,

413
00:19:37 --> 00:19:40
so this is just an assignment
and I going to take test to be

414
00:19:40 --> 00:19:42
the value of that, of course
nothing gets printed because

415
00:19:42 --> 00:19:43
that was an assignment
statement.

416
00:19:43 --> 00:19:44
All right?


417
00:19:44 --> 00:19:47
So if I called sqrt alone, that
return value is done, but in

418
00:19:47 --> 00:19:49
this case I bound it to
test, so I can go look at

419
00:19:49 --> 00:19:51
test, and there it is.


420
00:19:51 --> 00:19:58
What happens if I do that?


421
00:19:58 --> 00:19:59
OK.


422
00:19:59 --> 00:20:01
If you look at the code, it
printed out, it's not a perfect

423
00:20:01 --> 00:20:03
square, which is what I wanted,
but now, what's the

424
00:20:03 --> 00:20:05
value of test?


425
00:20:05 --> 00:20:09
OK, I bound test to something,
if I look at it, it doesn't

426
00:20:09 --> 00:20:16
print anything, but-- if I
could type-- I can ask, is

427
00:20:16 --> 00:20:20
test bound to that
special name none?

428
00:20:20 --> 00:20:23
The answer is yes.


429
00:20:23 --> 00:20:24
Boy, this seems like
a nuance, right?

430
00:20:24 --> 00:20:25
But it's a valuable thing.


431
00:20:25 --> 00:20:30
It says, in each case, I
return some useful value

432
00:20:30 --> 00:20:31
from this procedure.


433
00:20:31 --> 00:20:34
I can check it, so if this was
part of some other computation,

434
00:20:34 --> 00:20:36
I want to know, did it find
a perfect square or not?

435
00:20:36 --> 00:20:39
I don't have to go read what
it printed out in the screen.

436
00:20:39 --> 00:20:41
This has returned a
value that I can use.

437
00:20:41 --> 00:20:44
Because I could do a test to
say, is this a return value?

438
00:20:44 --> 00:20:46
If it's not, I'll do
something else with it.

439
00:20:46 --> 00:20:51
So the binding is still there,
it simply doesn't print it out.

440
00:20:51 --> 00:20:51
OK.


441
00:20:51 --> 00:20:53
What do we have out of this?


442
00:20:53 --> 00:20:56
Simple, seems like,
at least addition.

443
00:20:56 --> 00:20:59
We've added this
notion of a function.

444
00:20:59 --> 00:21:02
I've highlighted some of the
key things we got here, right?

445
00:21:02 --> 00:21:05
We have that def keyword, we've
got a name, we've got a list--

446
00:21:05 --> 00:21:07
or I shouldn't say a word list,
we have a collection of formal

447
00:21:07 --> 00:21:10
parameters that we're going to
use-- we have a body, and the

448
00:21:10 --> 00:21:12
body looks just like the normal
instructions we'd use, although

449
00:21:12 --> 00:21:15
by the way, we ought to be able
to use functions inside the

450
00:21:15 --> 00:21:17
body, which we're going to do
in a second, and then we're

451
00:21:17 --> 00:21:20
going to simply return
some values out of this.

452
00:21:20 --> 00:21:23
Now I started by saying,
build these functions.

453
00:21:23 --> 00:21:27
I'm trying to get both
decomposition and abstraction.

454
00:21:27 --> 00:21:29
Well, you hopefully can see
the decomposition, right?

455
00:21:29 --> 00:21:30
I now have a module.


456
00:21:30 --> 00:21:33
OK, let me set the stage.


457
00:21:33 --> 00:21:35
Imagine I wanted to do sqrt, or
square root-- no, I'm going to

458
00:21:35 --> 00:21:37
use sqrt, that's the name I'm
using here-- square root a

459
00:21:37 --> 00:21:40
hundred different places
in some piece of code.

460
00:21:40 --> 00:21:43
Without function, I'd
have to copy that piece

461
00:21:43 --> 00:21:44
of code everywhere.


462
00:21:44 --> 00:21:47
Now I got one just simple
thing, and I simply have

463
00:21:47 --> 00:21:51
isolated that module
inside of that function.

464
00:21:51 --> 00:21:53
What about abstraction?


465
00:21:53 --> 00:21:56
Well, I've got part of what
I want for abstraction.

466
00:21:56 --> 00:21:58
Abstraction, again, says I'm
going to suppress details.

467
00:21:58 --> 00:22:01
Now that I've written sqrt,
I can just use it anywhere

468
00:22:01 --> 00:22:02
I want in the code.


469
00:22:02 --> 00:22:05
You've got to rely on the fact
that I wrote it correctly, but

470
00:22:05 --> 00:22:08
you can basically suppress the
details of how it's used.

471
00:22:08 --> 00:22:10
There's one more piece that
we'd like to get out of that,

472
00:22:10 --> 00:22:13
and that is-- you may have been
wondering, what's with the

473
00:22:13 --> 00:22:17
funky stuttering here of three
double-quotes in a row.

474
00:22:17 --> 00:22:17
All right?


475
00:22:17 --> 00:22:20
And that is a specification.


476
00:22:20 --> 00:22:22
Which is a really
valuable thing to have.

477
00:22:22 --> 00:22:24
So what is the
specification going to do?

478
00:22:24 --> 00:22:28
It is my place, as a
programmer, to write

479
00:22:28 --> 00:22:30
information to the user.


480
00:22:30 --> 00:22:33
This is me writing one hour of
that episode of Pirandello and

481
00:22:33 --> 00:22:36
telling the other authors,
here's what I'm assuming

482
00:22:36 --> 00:22:37
as you use it.


483
00:22:37 --> 00:22:39
So it's up to me to do it
right, but if I do it, I'm

484
00:22:39 --> 00:22:42
going to specify, what
does this function do?

485
00:22:42 --> 00:22:45
What does it expect as input,
and any other information

486
00:22:45 --> 00:22:46
I want to pass on.


487
00:22:46 --> 00:22:49
And notice, by the way, if I do
that, I'm going to come down

488
00:22:49 --> 00:22:56
here, and I type sqrt and
open the paren, ah-ha!

489
00:22:56 --> 00:23:00
It shows me what the creator,
in this case actually I stole

490
00:23:00 --> 00:23:02
this from John so what
Professor Guttag put up as

491
00:23:02 --> 00:23:06
his specification for
this piece of code.

492
00:23:06 --> 00:23:07
Now, it's not guaranteed
it's right, right?

493
00:23:07 --> 00:23:09
You're trusting the programmer
did it right, but this

494
00:23:09 --> 00:23:10
now tells you something.


495
00:23:10 --> 00:23:11
What is this?


496
00:23:11 --> 00:23:13
This is a wonderful
piece of abstraction.

497
00:23:13 --> 00:23:16
It is saying, you don't need to
know squat about what's inside

498
00:23:16 --> 00:23:18
the body of this function.


499
00:23:18 --> 00:23:19
You don't have to worry about
the parameter names, because

500
00:23:19 --> 00:23:21
they're going to be preserved,
you don't need to worry about

501
00:23:21 --> 00:23:24
how I'm doing it, this tells
you how you can use this, in

502
00:23:24 --> 00:23:26
order to use it correctly.


503
00:23:26 --> 00:23:30
Of course, I can then close
it off, and off we go.

504
00:23:30 --> 00:23:32
All right, so that notion of
abstraction and I was going to

505
00:23:32 --> 00:23:34
come back-- we're going to come
back to multiple times during

506
00:23:34 --> 00:23:37
the term-- and it's not
just abstraction, it's the

507
00:23:37 --> 00:23:39
idea of a specification.


508
00:23:39 --> 00:23:41
And just to look ahead a little
bit, you could easily imagine

509
00:23:41 --> 00:23:43
that I might want to not just
put a statement in there, what

510
00:23:43 --> 00:23:46
the specs are, I might want
to put some constraints.

511
00:23:46 --> 00:23:49
Some specific things to check
for, to make sure that you're

512
00:23:49 --> 00:23:50
calling the code right.


513
00:23:50 --> 00:23:53
And it becomes a powerful way
of reasoning about the code, a

514
00:23:53 --> 00:23:56
powerful way of using the code,
so those notions of specs

515
00:23:56 --> 00:23:58
are really important.


516
00:23:58 --> 00:24:03
Look, part of the reason I'm
flaming at you is, something

517
00:24:03 --> 00:24:05
like square root, it seems
dumb to write specs on it.

518
00:24:05 --> 00:24:07
Everybody knows what
this is going to do.

519
00:24:07 --> 00:24:09
But you want to get into
that discipline of good

520
00:24:09 --> 00:24:10
hygiene, good style.


521
00:24:10 --> 00:24:13
You want to write the specs so
that everybody does in fact

522
00:24:13 --> 00:24:15
know what this piece of code is
doing, and you're writing

523
00:24:15 --> 00:24:18
it each time around.


524
00:24:18 --> 00:24:20
OK.


525
00:24:20 --> 00:24:25
Now that we've got functions,
let's see what we can do as

526
00:24:25 --> 00:24:27
a problem-solving
tool using them.

527
00:24:27 --> 00:24:29
In a particular, I've already
said I want to get this notion

528
00:24:29 --> 00:24:32
of modularity, it's a module I
can isolate, and I want to get

529
00:24:32 --> 00:24:35
the notion of abstracting away
the details, let's see how we

530
00:24:35 --> 00:24:39
can actually use that to
actually write some reasonably

531
00:24:39 --> 00:24:42
interesting pieces of code, but
in particular, to see how we

532
00:24:42 --> 00:24:45
can use it to capture the ideas
of decomposition

533
00:24:45 --> 00:24:47
and abstraction.


534
00:24:47 --> 00:24:49
So I'm going to shift gears.


535
00:24:49 --> 00:24:57
Start with a simple problem.


536
00:24:57 --> 00:24:59
Boy, we're suddenly be
transported to Nebraska.

537
00:24:59 --> 00:25:01
Or where I grew
up, Saskatchewan.

538
00:25:01 --> 00:25:03
All right, we've got
a farm air problem.

539
00:25:03 --> 00:25:07
I got a farmer, walks out
into his yard, one morning.

540
00:25:07 --> 00:25:11
This farmer has a bunch of pigs
in a punch-- it's been a long

541
00:25:11 --> 00:25:14
day-- a bunch of pigs and
a bunch of chickens.

542
00:25:14 --> 00:25:17
And he walks out into the
farmyard and he observes

543
00:25:17 --> 00:25:22
20 heads and 56 legs.


544
00:25:22 --> 00:25:27
And for sake of argument, there
are no amputees among the

545
00:25:27 --> 00:25:28
chickens and the pigs.


546
00:25:28 --> 00:25:31
And the question is, so how
many pigs does he have, and how

547
00:25:31 --> 00:25:33
many chickens does he have?


548
00:25:33 --> 00:25:34
Wow.


549
00:25:34 --> 00:25:36
What a deep problem, right?


550
00:25:36 --> 00:25:37
But you're going to see
why we're going to

551
00:25:37 --> 00:25:37
use this in a second.


552
00:25:37 --> 00:25:39
So you know how to solve
this, this is a fifth-grade

553
00:25:39 --> 00:25:40
problem, right?


554
00:25:40 --> 00:25:41
And what's the way
to solve this?

555
00:25:41 --> 00:25:43
System of linear equations.


556
00:25:43 --> 00:25:44
What are the equations here?


557
00:25:44 --> 00:25:48
Well, I could say, you know,
the number of pigs plus the

558
00:25:48 --> 00:25:53
number of chickens
equals 20, right?

559
00:25:53 --> 00:25:54
Because we've got 20 heads.


560
00:25:54 --> 00:25:55
And then what else do I have?


561
00:25:55 --> 00:26:00
Four times the number of pigs
plus two times the number of

562
00:26:00 --> 00:26:02
chickens, assuming they're not
next to a nuclear

563
00:26:02 --> 00:26:07
reactor, is 56.


564
00:26:07 --> 00:26:10
And then how would
you solve this?

565
00:26:10 --> 00:26:11
Well, it's, you sort of know
how you'd do it if this

566
00:26:11 --> 00:26:12
was grammar school right?


567
00:26:12 --> 00:26:14
You'd pull out your pencil and
paper, you can do it as a

568
00:26:14 --> 00:26:16
matrix inversion if you know
how to do that, or you can just

569
00:26:16 --> 00:26:19
simply do substitution of one
equation into another

570
00:26:19 --> 00:26:21
to solve it.


571
00:26:21 --> 00:26:23
That's certainly one way to
do it, but for computers

572
00:26:23 --> 00:26:26
that's not necessarily
the easiest way.

573
00:26:26 --> 00:26:29
So another way of solving it is
to do something we already saw

574
00:26:29 --> 00:26:32
last time, which is basically,
why not simply enumerate all

575
00:26:32 --> 00:26:35
possible examples
and check them?

576
00:26:35 --> 00:26:38
You could say, I could
have zero chickens and

577
00:26:38 --> 00:26:40
20 pigs, does that work?


578
00:26:40 --> 00:26:41
I've got one chicken and
nineteen pigs, does that work?

579
00:26:41 --> 00:26:43
I've got two chickens
and eighteen pigs,

580
00:26:43 --> 00:26:44
you get the idea.


581
00:26:44 --> 00:26:52
So I'm going to solve this by
enumerate and check, which is

582
00:26:52 --> 00:27:00
an example of what's called
a brute-force algorithm.

583
00:27:00 --> 00:27:02
Meaning, I'm just going
to write a little

584
00:27:02 --> 00:27:03
loop that does that.


585
00:27:03 --> 00:27:07
All right, so let's
go back to our code.

586
00:27:07 --> 00:27:09
That's right, let me
pull this over a little

587
00:27:09 --> 00:27:14
bit, so I can see it.


588
00:27:14 --> 00:27:16
And what I'd like you to look
at, I'm going to highlight it

589
00:27:16 --> 00:27:19
just for a second here, is
those two pieces of code.

590
00:27:19 --> 00:27:20
OK?


591
00:27:20 --> 00:27:24
Let's start with solve.


592
00:27:24 --> 00:27:24
OK.


593
00:27:24 --> 00:27:25
Here's the idea of solve.


594
00:27:25 --> 00:27:28
I'm going to have it take in as
input how many legs I got, how

595
00:27:28 --> 00:27:30
many heads do I have, and I
just want to write

596
00:27:30 --> 00:27:32
a little loop.


597
00:27:32 --> 00:27:32
OK.


598
00:27:32 --> 00:27:34
I know how to do that, right?


599
00:27:34 --> 00:27:36
Write a little loop, all
I'm going to do, is

600
00:27:36 --> 00:27:37
run a FOR loop here.


601
00:27:37 --> 00:27:40
I'm going to let the number of
chickens be in this range.

602
00:27:40 --> 00:27:43
Remember what range does, it
gives me a set or a collection

603
00:27:43 --> 00:27:48
or a tuple of integers from 0
up to 1 - is the last value, so

604
00:27:48 --> 00:27:49
it's going to give me
everything from 0 up to the

605
00:27:49 --> 00:27:51
total number of heads.


606
00:27:51 --> 00:27:53
Knowing that, I'm going to say,
OK, how many pigs are there,

607
00:27:53 --> 00:27:55
well that's just how we're,
however many I had total, minus

608
00:27:55 --> 00:27:58
that amount, and then I can
see, how many legs does that

609
00:27:58 --> 00:28:01
give, and then I can check,
that the number of legs that I

610
00:28:01 --> 00:28:03
would get for that solution, is
it even equal to the number

611
00:28:03 --> 00:28:06
of legs I started with, ah!


612
00:28:06 --> 00:28:06
Interesting.


613
00:28:06 --> 00:28:08
A return.


614
00:28:08 --> 00:28:10
In particular, I'm going
to return a tuple.

615
00:28:10 --> 00:28:14
So, a pair or collection
of those two values.

616
00:28:14 --> 00:28:17
If it isn't, then I'm going
to go back around the loop,

617
00:28:17 --> 00:28:18
and notice what happens.


618
00:28:18 --> 00:28:22
If I get all the way around the
loop, that is, all the way

619
00:28:22 --> 00:28:24
through that FOR loop and I
never find a path that takes me

620
00:28:24 --> 00:28:27
through here, then the last
thing I'm going to do is return

621
00:28:27 --> 00:28:30
a pair or a tuple with
a special simple

622
00:28:30 --> 00:28:32
number none twice.


623
00:28:32 --> 00:28:32
Yep.


624
00:28:32 --> 00:28:35
Are you telling me I
want parens there and

625
00:28:35 --> 00:28:36
not, and not braces?


626
00:28:36 --> 00:28:37
All right.


627
00:28:37 --> 00:28:40
I hate this language, because
I always want to have parens.

628
00:28:40 --> 00:28:42
Every time you see a square
bracket, put a paren in.

629
00:28:42 --> 00:28:44
All right?


630
00:28:44 --> 00:28:45
Thank you, Christy.


631
00:28:45 --> 00:28:48
I'll get it eventually .


632
00:28:48 --> 00:28:51
Having done that, right,
notice what I've got.

633
00:28:51 --> 00:28:53
First of all, two parameters.


634
00:28:53 --> 00:28:54
It's OK.


635
00:28:54 --> 00:28:56
All it says is, when I call
this, I need to pass in two

636
00:28:56 --> 00:28:58
parameters for this to work.


637
00:28:58 --> 00:29:00
All right?


638
00:29:00 --> 00:29:02
Now, if I want to use that, I'm
going to use a second piece of

639
00:29:02 --> 00:29:03
code here, called Barnyard.


640
00:29:03 --> 00:29:06
I'm going to read in a couple
of values, convert them into

641
00:29:06 --> 00:29:09
integers, and then I'm going
to use solve to get

642
00:29:09 --> 00:29:11
a solution out.


643
00:29:11 --> 00:29:12
And what do I know about solve?


644
00:29:12 --> 00:29:16
It is going to give me back a
tuple a collection of two

645
00:29:16 --> 00:29:19
things, and so check
out the syntax.

646
00:29:19 --> 00:29:22
I can give two names, which
will get bound to the two

647
00:29:22 --> 00:29:25
parts of that return tuple.


648
00:29:25 --> 00:29:27
OK, pigs will be the first
part, chickens will

649
00:29:27 --> 00:29:29
be the second part.


650
00:29:29 --> 00:29:31
OK, and then once I've got
that, well, notice: I can then

651
00:29:31 --> 00:29:35
check to see, did I return
that special symbol none?

652
00:29:35 --> 00:29:36
Is the first part.


653
00:29:36 --> 00:29:38
That says, I took the branch
through here that eventually

654
00:29:38 --> 00:29:40
got to the end and said,
there wasn't a solution,

655
00:29:40 --> 00:29:41
in which case I'm


656
00:29:41 --> 00:29:44
going to print out, there
ain't no solution, otherwise

657
00:29:44 --> 00:29:47
I'll print out the pieces.


658
00:29:47 --> 00:29:51
All right, let's check it out.


659
00:29:51 --> 00:29:51
Ah, what did I say?


660
00:29:51 --> 00:29:54
Twenty and 56, Right?


661
00:29:54 --> 00:29:57
OK, notice the form.


662
00:29:57 --> 00:30:02
I've got two parameters,
they're separated by a comma.

663
00:30:02 --> 00:30:05
Ah, right.


664
00:30:05 --> 00:30:09
Sorry?


665
00:30:09 --> 00:30:11
Yeah, but I see-- it's
legs and heads, but it

666
00:30:11 --> 00:30:16
should not still have--


667
00:30:16 --> 00:30:17
Oh, sorry.


668
00:30:17 --> 00:30:18
Thank you.


669
00:30:18 --> 00:30:19
I've been doing
the wrong thing.

670
00:30:19 --> 00:30:24
I want Barnyard this way, and
if I had looked when I opened

671
00:30:24 --> 00:30:26
the paren, it would have
shown me a closed paren

672
00:30:26 --> 00:30:27
with no parameters.


673
00:30:27 --> 00:30:29
Aren't you glad I make
mistakes, so you can see how

674
00:30:29 --> 00:30:30
well I can fix from these?


675
00:30:30 --> 00:30:31
All right.


676
00:30:31 --> 00:30:33
Now I call that, and it says,
tell me how many heads you

677
00:30:33 --> 00:30:37
want, give it a 20, and tell it
how many legs you want, give it

678
00:30:37 --> 00:30:43
56, and it prints
out the answers.

679
00:30:43 --> 00:30:43
I know, whoop-dee-doo.


680
00:30:43 --> 00:30:45
But notice what's
inside if here.

681
00:30:45 --> 00:30:47
First of all, notice
the modularity.

682
00:30:47 --> 00:30:48
I've used solve.


683
00:30:48 --> 00:30:50
All right?


684
00:30:50 --> 00:30:51
Right there.


685
00:30:51 --> 00:30:53
I've captured it
as a computation.

686
00:30:53 --> 00:30:57
It's buried away, all the
details are suppressed.

687
00:30:57 --> 00:31:00
I can use that to return
values, which I can then use

688
00:31:00 --> 00:31:02
elsewhere, which I did-- and
if I just come back and

689
00:31:02 --> 00:31:05
highlight this-- inside
of that computation.

690
00:31:05 --> 00:31:08
But I don't have to know,
inside of Barnyard, what

691
00:31:08 --> 00:31:11
the values are used
inside of solve.

692
00:31:11 --> 00:31:13
I don't know what the names of
the variables are, I don't

693
00:31:13 --> 00:31:17
care, I can basically
suppress away that detail.

694
00:31:17 --> 00:31:20
Second thing we saw is, that
using this as a computation, I

695
00:31:20 --> 00:31:22
can return multiple values.


696
00:31:22 --> 00:31:25
Which is actually of real value
to me here as I use that.

697
00:31:25 --> 00:31:26
OK.


698
00:31:26 --> 00:31:27
Yeah.


699
00:31:27 --> 00:31:27
Question.


700
00:31:27 --> 00:31:38
STUDENT: [INAUDIBLE]


701
00:31:38 --> 00:31:39
PROFESSOR ERIC GRIMSON: Ah.


702
00:31:39 --> 00:31:40
The question was, when
it returns, how does

703
00:31:40 --> 00:31:42
it distinguish between
local and other things?

704
00:31:42 --> 00:31:43
So let me try and answer that.


705
00:31:43 --> 00:31:47
Inside of solve, solve creates
an environment where inside of

706
00:31:47 --> 00:31:50
that, it has bindings for the
parameters it's going to use.

707
00:31:50 --> 00:31:51
All right?


708
00:31:51 --> 00:31:54
Like, number of-- wait, what
did we call a were solve--

709
00:31:54 --> 00:31:56
number of legs and
number of heads.

710
00:31:56 --> 00:31:58
OK, those are bound locally.


711
00:31:58 --> 00:32:01
When solve is done, it
wraps up, if you like, a

712
00:32:01 --> 00:32:03
value that it returns.


713
00:32:03 --> 00:32:04
Which is that.


714
00:32:04 --> 00:32:09
That expression, or that value,
or that value, literally gets

715
00:32:09 --> 00:32:13
passed back out of that local
environment to the value

716
00:32:13 --> 00:32:14
that comes back out of it.


717
00:32:14 --> 00:32:18
So in particular, what's
solved returns is a pair.

718
00:32:18 --> 00:32:22
It could be the pair of none,
none, it could be the pair of,

719
00:32:22 --> 00:32:24
you know, whatever the answer
was that we put up there.

720
00:32:24 --> 00:32:28
That value comes back out
and is now available inside

721
00:32:28 --> 00:32:30
the scope of Barnyard.


722
00:32:30 --> 00:32:31
OK.


723
00:32:31 --> 00:32:33
And Barnyard then uses that.


724
00:32:33 --> 00:32:34
Question?


725
00:32:34 --> 00:32:39
STUDENT: [INAUDIBLE]


726
00:32:39 --> 00:32:40
PROFESSOR ERIC GRIMSON: Here?


727
00:32:40 --> 00:32:41
So the question is, why
is this return on the

728
00:32:41 --> 00:32:43
same level as the FOR?


729
00:32:43 --> 00:32:43
Why do you think?


730
00:32:43 --> 00:32:56
STUDENT: [INAUDIBLE]


731
00:32:56 --> 00:32:56
PROFESSOR ERIC GRIMSON: No.


732
00:32:56 --> 00:32:57
Good question.


733
00:32:57 --> 00:32:57
All right?


734
00:32:57 --> 00:32:58
So what's going to happen here?


735
00:32:58 --> 00:33:02
If I'm inside this FOR, OK, and
I'm running around, if I ever

736
00:33:02 --> 00:33:07
hit a place where this test is
true, I'm going to execute that

737
00:33:07 --> 00:33:11
return, that return returns
from the entire procedure.

738
00:33:11 --> 00:33:11
OK?


739
00:33:11 --> 00:33:13
So the return comes back
from the procedure.

740
00:33:13 --> 00:33:17
So the question was, why is
this return down at this level,

741
00:33:17 --> 00:33:20
it says, well if I ever execute
out of this FOR loop, I get to

742
00:33:20 --> 00:33:22
the end of the FOR loop without
hitting that branch that took

743
00:33:22 --> 00:33:27
me through the return, then and
only then do I want to actually

744
00:33:27 --> 00:33:29
say, gee, I got to this place,
there isn't any value to

745
00:33:29 --> 00:33:31
return, I'm going to
return none and none.

746
00:33:31 --> 00:33:33
I'm still trying to get rid
of this candy, Halloween's

747
00:33:33 --> 00:33:34
coming, where were we?


748
00:33:34 --> 00:33:36
There's one, thank you.


749
00:33:36 --> 00:33:38
I don't think I'm going
to make it, I did.

750
00:33:38 --> 00:33:41
Thank you.


751
00:33:41 --> 00:33:48
Make sense?


752
00:33:48 --> 00:33:51
The answer is no, I want parens
to create tuple and I get

753
00:33:51 --> 00:33:52
really confused about the
difference between

754
00:33:52 --> 00:33:53
lists and tuples.


755
00:33:53 --> 00:34:00
For now, the code is working.


756
00:34:00 --> 00:34:02
Yes is the answer, all right?


757
00:34:02 --> 00:34:04
And we're having a difference
of opinion as to whether we

758
00:34:04 --> 00:34:06
should use a tuple or
a list here, right?

759
00:34:06 --> 00:34:08
But the answer is yes, you can.


760
00:34:08 --> 00:34:10
And my real answer is, go try
it out, because obviously you

761
00:34:10 --> 00:34:12
can tell I frequently do this
the wrong way and the TAs give

762
00:34:12 --> 00:34:13
me a hard time every time.


763
00:34:13 --> 00:34:14
John.


764
00:34:14 --> 00:34:17
PROFESSOR JOHN GUTTAG:
Is the microphone on?

765
00:34:17 --> 00:34:18
PROFESSOR ERIC GRIMSON: Yes.


766
00:34:18 --> 00:34:21
PROFESSOR JOHN GUTTAG: As
you'll see next week, tuples

767
00:34:21 --> 00:34:23
and lists are very close
to the same thing.

768
00:34:23 --> 00:34:27
In almost any place where
you can get away with using

769
00:34:27 --> 00:34:29
tuples you can use lists.


770
00:34:29 --> 00:34:29
PROFESSOR ERIC GRIMSON: Yes.


771
00:34:29 --> 00:34:32
PROFESSOR JOHN GUTTAG: But want
to emphasize word is almost,

772
00:34:32 --> 00:34:35
because we'll see a couple of
places where if it expects

773
00:34:35 --> 00:34:38
a tuple and you use a list
you'll get an error message.

774
00:34:38 --> 00:34:40
But we'll see all
that next week.

775
00:34:40 --> 00:34:42
PROFESSOR ERIC GRIMSON: Right,
when the real pro comes in

776
00:34:42 --> 00:34:46
to pick up the pieces I'm
leaving behind for him.

777
00:34:46 --> 00:34:47
OK.


778
00:34:47 --> 00:34:48
Let me pull this back up.


779
00:34:48 --> 00:34:51
What we're doing now is we're
building this encapsulation.

780
00:34:51 --> 00:34:53
Now one of the things you
notice here by the way is, you

781
00:34:53 --> 00:34:57
know, this in essence just
solves the simple problems.

782
00:34:57 --> 00:35:01
Suppose I now add one
other piece to this.

783
00:35:01 --> 00:35:04
The farmer is not keeping a
great set of things so in

784
00:35:04 --> 00:35:11
addition to pigs, and
chickens he raises spiders.

785
00:35:11 --> 00:35:14
I have no idea why.


786
00:35:14 --> 00:35:16
He's making silk I guess.


787
00:35:16 --> 00:35:17
Right?


788
00:35:17 --> 00:35:18
Why am I giving
you this example?

789
00:35:18 --> 00:35:20
I want to show you how easy
it is to change the code.

790
00:35:20 --> 00:35:22
But, notice, once I've added
this I actually have a problem.

791
00:35:22 --> 00:35:24
This is now an
under-constrained problem.

792
00:35:24 --> 00:35:28
I have more unknowns
than I have equations.

793
00:35:28 --> 00:35:30
So you know from algebra I
can't actually solve this.

794
00:35:30 --> 00:35:33
There may be multiple
solutions to this.

795
00:35:33 --> 00:35:35
What would I have to
do to change my code?

796
00:35:35 --> 00:35:38
And the answer is
fortunately not a lot.

797
00:35:38 --> 00:35:41
So I'm going to ask you to look
now at this set of things,

798
00:35:41 --> 00:35:45
which is solve 1
and Barnyard 1.

799
00:35:45 --> 00:35:47
OK.


800
00:35:47 --> 00:35:49
The change is, well, on
Barnyard 1 it looks much the

801
00:35:49 --> 00:35:50
same as it did for Barnyard.


802
00:35:50 --> 00:35:52
Right, I'm going to read in the
values of the number of heads

803
00:35:52 --> 00:35:53
and the number of legs.


804
00:35:53 --> 00:35:56
I'm going to use solve 1 as
before, but now I'm going to

805
00:35:56 --> 00:35:58
bind out three variables.


806
00:35:58 --> 00:35:59
And then I'm going to
do a similar thing

807
00:35:59 --> 00:36:01
to print things out.


808
00:36:01 --> 00:36:02
But would the solver do?


809
00:36:02 --> 00:36:04
Well here what I'd like
to do is to run through

810
00:36:04 --> 00:36:06
a couple of loops.


811
00:36:06 --> 00:36:07
Right, how would I
solve this problem?

812
00:36:07 --> 00:36:11
You can use the same enumerate
and check idea, but now say gee

813
00:36:11 --> 00:36:13
let me pick how many
pigs there are.

814
00:36:13 --> 00:36:14
Is that the one I used first?


815
00:36:14 --> 00:36:18
Sorry, let me pick the number
of spiders there are.

816
00:36:18 --> 00:36:20
Having chosen the number of
spiders, let me pick how

817
00:36:20 --> 00:36:24
many chickens I have.


818
00:36:24 --> 00:36:26
With those two in place, I now
know how many pigs I must have

819
00:36:26 --> 00:36:28
and I can run through
the same solution.

820
00:36:28 --> 00:36:31
The reason I'm showing you
this is this is another

821
00:36:31 --> 00:36:32
very standard structure.


822
00:36:32 --> 00:36:35
I now have two nested loops.


823
00:36:35 --> 00:36:38
One running through a choice
for one parameter, another

824
00:36:38 --> 00:36:40
one running through a choice
for a second parameter.

825
00:36:40 --> 00:36:41
And then the rest of
the solution looks

826
00:36:41 --> 00:36:42
much like before.


827
00:36:42 --> 00:36:44
I'm going to get the total
number of legs out.

828
00:36:44 --> 00:36:45
I'm going to check to see
if it's right or not.

829
00:36:45 --> 00:36:48
And again I'm going to return
either a three tuple there

830
00:36:48 --> 00:36:50
or a three tuple there.


831
00:36:50 --> 00:36:51
It's part of what I want,
because I'm going to

832
00:36:51 --> 00:36:53
bind those values out.


833
00:36:53 --> 00:37:03
And if I run that example,
Barnyard 1, I don't know we'll

834
00:37:03 --> 00:37:09
give it 20 heads, 56 legs;
and it find a solution.

835
00:37:09 --> 00:37:14
I ought to be able to
run something else.

836
00:37:14 --> 00:37:15
I don't know, give
me some numbers.

837
00:37:15 --> 00:37:15
How many heads?


838
00:37:15 --> 00:37:17
Pick an integer, somebody.


839
00:37:17 --> 00:37:18
STUDENT: 5.


840
00:37:18 --> 00:37:19
PROFESSOR ERIC GRIMSON: 5.


841
00:37:19 --> 00:37:19
All right.


842
00:37:19 --> 00:37:22
How many legs?


843
00:37:22 --> 00:37:24
10?


844
00:37:24 --> 00:37:24
All right.


845
00:37:24 --> 00:37:26
We got an easy one.


846
00:37:26 --> 00:37:28
Let's just for the heck of
it -- I should have found

847
00:37:28 --> 00:37:37
some better examples
before I tried this.

848
00:37:37 --> 00:37:40
No mutant spiders here.


849
00:37:40 --> 00:37:41
OK, so what have I done?


850
00:37:41 --> 00:37:42
I just added a little
bit more now.

851
00:37:42 --> 00:37:43
I'm now running through
a pair of loops.

852
00:37:43 --> 00:37:46
Again notice the encapsulation,
that nice abstraction going

853
00:37:46 --> 00:37:48
on, which is what I want.


854
00:37:48 --> 00:37:50
Once I get to this stage though
by the way, there might be

855
00:37:50 --> 00:37:51
more than one solution.


856
00:37:51 --> 00:37:54
Because in an under-constrained
problem there could be

857
00:37:54 --> 00:37:55
multiple solutions.


858
00:37:55 --> 00:37:57
So suppose I want to capture
all of them or print

859
00:37:57 --> 00:37:59
all of them out.


860
00:37:59 --> 00:38:00
Well I ought to be able
to do that by simply

861
00:38:00 --> 00:38:02
generalizing the loop.


862
00:38:02 --> 00:38:07
And that's what the next
piece of code on your

863
00:38:07 --> 00:38:08
a hand out shows you.


864
00:38:08 --> 00:38:09
I'm just going to let
you look at this.

865
00:38:09 --> 00:38:13
If you look at solve 2, it's
going to run through the

866
00:38:13 --> 00:38:16
same kind of loop, printing
out all of the answers.

867
00:38:16 --> 00:38:17
But it's going to keep going.


868
00:38:17 --> 00:38:19
In other words it doesn't just
return when it finds one, it's

869
00:38:19 --> 00:38:22
going to run through
all of them.

870
00:38:22 --> 00:38:23
All right?


871
00:38:23 --> 00:38:24
Sounds like a reasonable
thing to do.

872
00:38:24 --> 00:38:26
Notice one last piece.


873
00:38:26 --> 00:38:30
If I'm going to do that, run
through all possible answers, I

874
00:38:30 --> 00:38:32
still want to know, gee, what
if there aren't any answers?

875
00:38:32 --> 00:38:35
How do I return that case?


876
00:38:35 --> 00:38:37
And that shows you one other
nice little thing we want to

877
00:38:37 --> 00:38:40
do, which is if I look in this
code notice I set up a variable

878
00:38:40 --> 00:38:44
up here called Solution Found,
initially bound to false.

879
00:38:44 --> 00:38:47
The rest of that code's
a pair of loops.

880
00:38:47 --> 00:38:48
Pick the number of spiders.


881
00:38:48 --> 00:38:49
Pick the number of chickens.


882
00:38:49 --> 00:38:50
That sets up the
number of pigs.

883
00:38:50 --> 00:38:51
Figure out the legs.


884
00:38:51 --> 00:38:52
See if it's right.


885
00:38:52 --> 00:38:55
If it is right, I'm going to
print out the information but

886
00:38:55 --> 00:38:58
I'm also going to change
that variable to true.

887
00:38:58 --> 00:39:01
And that allows me then, at the
end of that pair of loops when

888
00:39:01 --> 00:39:05
I get down to this point right
here, I can check to see did I

889
00:39:05 --> 00:39:08
find any solution and if not
in that case print out

890
00:39:08 --> 00:39:11
there is no solution.


891
00:39:11 --> 00:39:14
So this gives you another nice
piece which is I can now look

892
00:39:14 --> 00:39:17
for first solution, I can look
for all solutions, and I can

893
00:39:17 --> 00:39:19
maintain some internal
variables that let me

894
00:39:19 --> 00:39:20
know what I found.


895
00:39:20 --> 00:39:22
A trick that you're going
to use a lot as you write

896
00:39:22 --> 00:39:24
your own functions.


897
00:39:24 --> 00:39:27
All right, I want to end up
with the last 10 minutes with a

898
00:39:27 --> 00:39:30
different variation on how to
use functions to think

899
00:39:30 --> 00:39:31
about problems.


900
00:39:31 --> 00:39:35
And that is to introduce
the idea of recursion.

901
00:39:35 --> 00:39:44
How many of you have heard
the term used before?

902
00:39:44 --> 00:39:47
How may have you heard the
term used before in terms

903
00:39:47 --> 00:39:50
of programming languages?


904
00:39:50 --> 00:39:51
Great.


905
00:39:51 --> 00:39:52
For the rest you,
don't sweat it.

906
00:39:52 --> 00:39:55
This is a highfalutin term that
computer scientists use to try

907
00:39:55 --> 00:39:58
and make them look like they're
smarter than they really are.

908
00:39:58 --> 00:40:01
But it is a very handy way of
thinking about, not just how

909
00:40:01 --> 00:40:04
to program, but how to break
problems down into

910
00:40:04 --> 00:40:06
nice sized chunks.


911
00:40:06 --> 00:40:09
And the idea behind recursion
I'm going to describe

912
00:40:09 --> 00:40:11
with a simple example.


913
00:40:11 --> 00:40:16
And then I'm going to show you
how we can actually use it.

914
00:40:16 --> 00:40:20
The idea of recursion is that
I'm going to take a problem and

915
00:40:20 --> 00:40:24
break it down into a simpler
version of the same problem

916
00:40:24 --> 00:40:26
plus some steps that
I can execute.

917
00:40:26 --> 00:40:28
I'm go to show you an example
of a procedure, sorry a

918
00:40:28 --> 00:40:29
function, in a second.


919
00:40:29 --> 00:40:32
But let me give you
actually an analogy.

920
00:40:32 --> 00:40:37
If you look at US law, and you
look at the definition of the

921
00:40:37 --> 00:40:39
US legal code that defines the
notion of a natural

922
00:40:39 --> 00:40:41
born US citizen.


923
00:40:41 --> 00:40:43
It's actually a wonderful
recursive definition.

924
00:40:43 --> 00:40:45
So what's the definition?


925
00:40:45 --> 00:40:49
If you're born in the United
States you are by definition

926
00:40:49 --> 00:40:51
a natural born US citizen.


927
00:40:51 --> 00:40:58
We call that a base case.


928
00:40:58 --> 00:41:05
It's basically the simplest
possible solution

929
00:41:05 --> 00:41:07
to the problem.


930
00:41:07 --> 00:41:09
Now if you were not born in the
United States, you may still

931
00:41:09 --> 00:41:14
be, under definition, a natural
born US citizen if you're born

932
00:41:14 --> 00:41:17
outside this United States,
both of your parents are

933
00:41:17 --> 00:41:20
citizens of the United States
and at least one parent has

934
00:41:20 --> 00:41:21
lived in the United States.


935
00:41:21 --> 00:41:24
There's a wonderful
legal expression.

936
00:41:24 --> 00:41:25
But notice what that is.


937
00:41:25 --> 00:41:26
It's a recursive definition.


938
00:41:26 --> 00:41:30
How do you know that your
parents, at least one of

939
00:41:30 --> 00:41:32
your parents satisfies
the definition?

940
00:41:32 --> 00:41:36
Well I've reduced the problem
from am I a natural born US

941
00:41:36 --> 00:41:41
citizen to is one of my parents
a natural born US citizen?

942
00:41:41 --> 00:41:44
And that may generalize again
and it keeps going until you

943
00:41:44 --> 00:41:46
either get back to Adam
and Eve, I guess.

944
00:41:46 --> 00:41:49
I don't think they were born in
the US as far as I know, or you

945
00:41:49 --> 00:41:52
find somebody who satisfies
that definition or you find

946
00:41:52 --> 00:41:55
that none of your parents
actually are in that category.

947
00:41:55 --> 00:42:00
But that second one is called
the inductive step, or

948
00:42:00 --> 00:42:01
the recursive step.


949
00:42:01 --> 00:42:10
And in my words it says break
the problem into a simpler

950
00:42:10 --> 00:42:28
version of the same problem
and some other steps.

951
00:42:28 --> 00:42:31
And I think this is best
illustrated by giving you a

952
00:42:31 --> 00:42:33
simple little piece of code.


953
00:42:33 --> 00:42:35
I use simple advisedly here.


954
00:42:35 --> 00:42:38
This is actually a piece of
code that is really easy to

955
00:42:38 --> 00:42:40
think about recursively and
is much more difficult to

956
00:42:40 --> 00:42:42
think about in other ways.


957
00:42:42 --> 00:42:44
And the piece of code is
suppose I have a spring

958
00:42:44 --> 00:42:46
and I want to know if
it's a palindrome.

959
00:42:46 --> 00:42:50
Does it read the same thing
left to right as right to left.

960
00:42:50 --> 00:42:51
OK?


961
00:42:51 --> 00:42:53
How would I solve that?


962
00:42:53 --> 00:42:57
If the string has no elements
in it it is obviously

963
00:42:57 --> 00:42:59
a palindrome.


964
00:42:59 --> 00:43:02
If the string has one element
in it, it's a palindrome.

965
00:43:02 --> 00:43:04
There's the base case.


966
00:43:04 --> 00:43:07
If it's longer than one,
what do I want to do?

967
00:43:07 --> 00:43:10
Well I'd like to check the
two end points to see are

968
00:43:10 --> 00:43:12
they the same character?


969
00:43:12 --> 00:43:14
And if they are, then oh,
I just need to know is

970
00:43:14 --> 00:43:19
everything else in the
middle a palindrome?

971
00:43:19 --> 00:43:21
I know it sounds simple, but
notice what I just did.

972
00:43:21 --> 00:43:23
I just used a
recursive definition.

973
00:43:23 --> 00:43:27
I just reduced it to a smaller
version of the same problem.

974
00:43:27 --> 00:43:30
That is if I can write code
that would solve all instances

975
00:43:30 --> 00:43:34
of smaller size strings, then
what I just described will

976
00:43:34 --> 00:43:36
solve the larger size one.


977
00:43:36 --> 00:43:38
And in fact that's
exactly what I have.

978
00:43:38 --> 00:43:40
I would like you to look at
this piece of code right

979
00:43:40 --> 00:43:44
here called isPalindrome.


980
00:43:44 --> 00:43:46
Notice what it says.


981
00:43:46 --> 00:43:51
I'm going to pass in a string,
call it s, binds it locally,

982
00:43:51 --> 00:43:52
and it says the following.


983
00:43:52 --> 00:43:57
It says if this is a string
of length 0 or 1, I'm done.

984
00:43:57 --> 00:44:00
I'm going to return
the answer true.

985
00:44:00 --> 00:44:04
Otherwise I'm going to check to
see is the first and last,

986
00:44:04 --> 00:44:07
there's that - 1 indexing, is
the first and last element

987
00:44:07 --> 00:44:10
of the string the same?


988
00:44:10 --> 00:44:14
And if that's true is
everything in the string,

989
00:44:14 --> 00:44:17
starting at the first element
and removing the last

990
00:44:17 --> 00:44:19
element, a palindrome?


991
00:44:19 --> 00:44:19
Let me remind you.


992
00:44:19 --> 00:44:21
By saying first element
remember we start at 0 as

993
00:44:21 --> 00:44:24
the initial indexing point.


994
00:44:24 --> 00:44:27
Wonderful recursive definition.


995
00:44:27 --> 00:44:31
OK, let's try it out.


996
00:44:31 --> 00:44:35
Go back over here and we're
going to say isPalindrome.

997
00:44:35 --> 00:44:37
How did I actually spell this?


998
00:44:37 --> 00:44:42
Palindrome with a capital P.


999
00:44:42 --> 00:44:46
Only in New York, in Canada
we pronounce it Palindrome.

1000
00:44:46 --> 00:44:48
When you're teaching it you
get to call it your way, I'm

1001
00:44:48 --> 00:44:49
going to call it my way.


1002
00:44:49 --> 00:44:52
Sorry John, you're
absolutely right.

1003
00:44:52 --> 00:44:53
OK.


1004
00:44:53 --> 00:44:55
Notice by the way, there's
that nice speck going on

1005
00:44:55 --> 00:44:57
saying put a string here.


1006
00:44:57 --> 00:44:59
It's going to return true if
it's a PAIL-indrome and false

1007
00:44:59 --> 00:45:03
if it's a PAL-indrome.


1008
00:45:03 --> 00:45:05
And it says true.


1009
00:45:05 --> 00:45:07
Now maybe you're
bugged by this.

1010
00:45:07 --> 00:45:09
I know you're bugged by my
bad humor, but too bad.

1011
00:45:09 --> 00:45:11
Maybe you're bugged by this,
saying wait a minute, how

1012
00:45:11 --> 00:45:13
does this thing stop?


1013
00:45:13 --> 00:45:16
This is the kind of definition
that your high school geometry

1014
00:45:16 --> 00:45:17
teacher would have rapped
your knuckles over.

1015
00:45:17 --> 00:45:20
You can't define things
in terms of themselves.

1016
00:45:20 --> 00:45:22
This is an inductive
definition.

1017
00:45:22 --> 00:45:24
Actually we could prove
inductively that it holds,

1018
00:45:24 --> 00:45:25
but how do we know it stops?


1019
00:45:25 --> 00:45:28
Well notice what the
computation is doing. it's

1020
00:45:28 --> 00:45:31
looking first to see am I in
the base case, which I'm done.

1021
00:45:31 --> 00:45:34
If I'm not I'm just going
to reduce this to a

1022
00:45:34 --> 00:45:35
smaller computation.


1023
00:45:35 --> 00:45:38
And as long as that smaller
computation reduces to another

1024
00:45:38 --> 00:45:41
smaller computation, eventually
I ought to get to the place

1025
00:45:41 --> 00:45:43
where I'm down in
that base case.

1026
00:45:43 --> 00:45:46
And to see that I've written
another version of this, which

1027
00:45:46 --> 00:45:49
I'm going to use here, where
I'm going to give it a

1028
00:45:49 --> 00:45:56
little indentation.


1029
00:45:56 --> 00:45:58
I'm going to call
this palindrome 1.

1030
00:45:58 --> 00:45:59
Sorry about that.


1031
00:45:59 --> 00:45:59
Palindrome 1.


1032
00:45:59 --> 00:46:03
I'm going to give it a
little indentation so

1033
00:46:03 --> 00:46:07
that we can see this.


1034
00:46:07 --> 00:46:07
OK.


1035
00:46:07 --> 00:46:10
Code is right here.


1036
00:46:10 --> 00:46:13
And all it's doing is when I'm
getting into the different

1037
00:46:13 --> 00:46:15
places I'm simply printing out
information about where I am.

1038
00:46:15 --> 00:46:18
What I want you to see is
notice what happened here.

1039
00:46:18 --> 00:46:19
OK.


1040
00:46:19 --> 00:46:22
I'm calling palindrome
with that.

1041
00:46:22 --> 00:46:25
It first calls it
on that problem.

1042
00:46:25 --> 00:46:27
And the code over here says,
OK gee, if I'm in the

1043
00:46:27 --> 00:46:29
base case do something.


1044
00:46:29 --> 00:46:32
I'm not, so come down here
check that the two end points

1045
00:46:32 --> 00:46:38
a and a are the same and
call this again also.

1046
00:46:38 --> 00:46:39
Notice what happens.


1047
00:46:39 --> 00:46:42
There's this nice
unwrapping of the problem.

1048
00:46:42 --> 00:46:45
I just doubled the indentation
each time so you can see it.

1049
00:46:45 --> 00:46:49
So each successive call,
notice what's happening.

1050
00:46:49 --> 00:46:52
The argument is
getting reduced.

1051
00:46:52 --> 00:46:54
And we're going
another level in.

1052
00:46:54 --> 00:46:56
When we get down to this point,
we're calling it with just

1053
00:46:56 --> 00:46:58
a string of length one.


1054
00:46:58 --> 00:47:01
At that point we're in
the base case and we can

1055
00:47:01 --> 00:47:03
unwrap this computation.


1056
00:47:03 --> 00:47:04
We say, ah, that's now true.


1057
00:47:04 --> 00:47:06
So I can return true here.


1058
00:47:06 --> 00:47:08
Given that that's true and
I already checked the two

1059
00:47:08 --> 00:47:10
end points, that's
true, that's true.

1060
00:47:10 --> 00:47:14
And I unwrap the
computation to get back.

1061
00:47:14 --> 00:47:16
You are going to have
to go play with this.

1062
00:47:16 --> 00:47:18
Rock it if you like to try
and see where it goes.

1063
00:47:18 --> 00:47:21
But I want to stress again, as
long as I do the base case

1064
00:47:21 --> 00:47:25
right and my inductive or
recursive step reduces it to a

1065
00:47:25 --> 00:47:28
smaller version of the same
problem, the code will in fact

1066
00:47:28 --> 00:47:31
converge and give
me out an answer.

1067
00:47:31 --> 00:47:35
All right, I want to show you
one last example of using

1068
00:47:35 --> 00:47:37
recursion because we're
going to come back to this.

1069
00:47:37 --> 00:47:40
This is a classic example
of using recursion.

1070
00:47:40 --> 00:47:44
And that is dating from
the 1200s and it is

1071
00:47:44 --> 00:47:46
due to Fibonacci.


1072
00:47:46 --> 00:47:49
Does anyone know the
history of what Fibonacci

1073
00:47:49 --> 00:47:51
was trying to do?


1074
00:47:51 --> 00:47:52
Sorry, let me re-ask that.


1075
00:47:52 --> 00:47:56
Fibonacci.


1076
00:47:56 --> 00:47:58
Which actually is son of
Bonacci which is the name of

1077
00:47:58 --> 00:48:00
his father who was apparently
a very friendly guy.

1078
00:48:00 --> 00:48:05
First of all, does anyone know
what a Fibonacci number is?

1079
00:48:05 --> 00:48:06
Wow.


1080
00:48:06 --> 00:48:10
STUDENT: [INAUDIBLE]


1081
00:48:10 --> 00:48:11
PROFESSOR ERIC GRIMSON: Right,
we're going to do that in a

1082
00:48:11 --> 00:48:13
second, but the answer is
Fibonacci numbers, we

1083
00:48:13 --> 00:48:14
define the first two.


1084
00:48:14 --> 00:48:16
Which are both defined to
be, or I can define them

1085
00:48:16 --> 00:48:17
in multiple ways, 0 and 1.


1086
00:48:17 --> 00:48:19
And then the next Fibonacci
number is the sum of

1087
00:48:19 --> 00:48:20
the previous two.


1088
00:48:20 --> 00:48:22
And the next number is the
sum of the previous two.

1089
00:48:22 --> 00:48:23
Do you know the
history of this?

1090
00:48:23 --> 00:48:30
STUDENT: [INAUDIBLE].


1091
00:48:30 --> 00:48:32
PROFESSOR ERIC
GRIMSON: Exactly.

1092
00:48:32 --> 00:48:33
Thank you.


1093
00:48:33 --> 00:48:35
Bad throw, I'm playing
for the Yankees.

1094
00:48:35 --> 00:48:36
Sorry John.


1095
00:48:36 --> 00:48:38
The answer is Fibonacci
actually was actually

1096
00:48:38 --> 00:48:40
trying to count rabbits
back in the 1200s.

1097
00:48:40 --> 00:48:42
The idea was that rabbits
could mate after a

1098
00:48:42 --> 00:48:44
month, at age one month.


1099
00:48:44 --> 00:48:47
And so he said, if you start
off with a male and a female,

1100
00:48:47 --> 00:48:49
at the end of one month
they have an offspring.

1101
00:48:49 --> 00:48:52
Let's assume they
have two offspring.

1102
00:48:52 --> 00:48:53
At the end of the next
month let's assume those

1103
00:48:53 --> 00:48:54
offspring have offspring.


1104
00:48:54 --> 00:48:55
Again a male and female.


1105
00:48:55 --> 00:48:57
The question was how many
rabbits do you have

1106
00:48:57 --> 00:48:58
at the end of a year?


1107
00:48:58 --> 00:48:58
At the end of two years?


1108
00:48:58 --> 00:49:01
At the end of more than that
number of years, and so.

1109
00:49:01 --> 00:49:05
We can do this with the
following level definition.

1110
00:49:05 --> 00:49:08
We're going to let pairs of 0,
the number of pairs at month 0,

1111
00:49:08 --> 00:49:10
actually it would not
be 0 it would be 1.

1112
00:49:10 --> 00:49:17
We let the number of
pairs at month 1 be 1.

1113
00:49:17 --> 00:49:22
And then the number of pairs at
month n is the number of pairs

1114
00:49:22 --> 00:49:27
at month n - 1 plus the number
of pairs at month n - 2.

1115
00:49:27 --> 00:49:30
The sum of the previous two.


1116
00:49:30 --> 00:49:35
If I write Fibonacci,
you see it right there.

1117
00:49:35 --> 00:49:37
And the reason I want to show
you this is to notice that the

1118
00:49:37 --> 00:49:39
recursion can be doubled.


1119
00:49:39 --> 00:49:43
So this says, given a value x,
if it's either 0 or 1, either

1120
00:49:43 --> 00:49:45
of those two cases,
just return 1.

1121
00:49:45 --> 00:49:49
Otherwise break this down
into two versions of

1122
00:49:49 --> 00:49:50
a simpler problem.


1123
00:49:50 --> 00:49:54
Fib of x - 1 and fib of x - 2,
and then take the sum of those

1124
00:49:54 --> 00:49:57
and return that as the value.


1125
00:49:57 --> 00:50:01
Notice if I'm going to have two
different sub problems I need

1126
00:50:01 --> 00:50:04
to have two base cases
here to catch this.

1127
00:50:04 --> 00:50:06
And if I only had one
it would error out.

1128
00:50:06 --> 00:50:11
And as a consequence, I can go
off and ask about rabbits.

1129
00:50:11 --> 00:50:13
Let's see.


1130
00:50:13 --> 00:50:18
At the end of 12
months, not so bad.

1131
00:50:18 --> 00:50:24
At the end of two years,
we're not looking so good.

1132
00:50:24 --> 00:50:30
At the end of three years,
we are now in Australia.

1133
00:50:30 --> 00:50:31
Overrun with rabbits.


1134
00:50:31 --> 00:50:34
In fact I don't think the
thing ever comes back, so I'm

1135
00:50:34 --> 00:50:37
going to stop it because it
really gets hung up here.

1136
00:50:37 --> 00:50:40
And I'm going to restart it.


1137
00:50:40 --> 00:50:42
What's the point of this?


1138
00:50:42 --> 00:50:44
Again, now that I can think
about things recursively, I can

1139
00:50:44 --> 00:50:47
similarly break things down
into simpler versions

1140
00:50:47 --> 00:50:48
of the same problem.


1141
00:50:48 --> 00:50:49
It could be one version.


1142
00:50:49 --> 00:50:51
It could be multiple versions.


1143
00:50:51 --> 00:50:53
And we're going to come back
throughout the term to think

1144
00:50:53 --> 00:50:56
about how to code programs
that reflect this.

1145
00:50:56 --> 00:50:59
The last point I want to make
to you is, you've started

1146
00:50:59 --> 00:51:01
writing programs that you
would think of as being

1147
00:51:01 --> 00:51:02
inherently iterative.


1148
00:51:02 --> 00:51:04
They're running through a loop.


1149
00:51:04 --> 00:51:06
It's a common way of
thinking about problems.

1150
00:51:06 --> 00:51:09
Some problems are naturally
tackled that way.

1151
00:51:09 --> 00:51:12
There are other problems that
are much more naturally thought

1152
00:51:12 --> 00:51:13
of in a recursive fashion.


1153
00:51:13 --> 00:51:16
And I would suggest palindrome
as a great example of that.

1154
00:51:16 --> 00:51:18
That's easy to think
about recursively.

1155
00:51:18 --> 00:51:20
It's much harder to think
about iteratively.

1156
00:51:20 --> 00:51:22
And you want to get into the
habit of deciding which is the

1157
00:51:22 --> 00:51:24
right one for you to use.


1158
00:51:24 --> 00:51:27
And with that, we'll
see you next time.


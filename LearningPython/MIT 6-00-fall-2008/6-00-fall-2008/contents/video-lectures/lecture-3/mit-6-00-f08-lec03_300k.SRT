1
00:00:00 --> 00:00:00



2
00:00:00 --> 00:00:02
The following content is
provided under a Creative

3
00:00:02 --> 00:00:03
Commons license.


4
00:00:03 --> 00:00:06
Your support will help MIT
OpenCourseware continue to

5
00:00:06 --> 00:00:10
offer high-quality educational
resources for free.

6
00:00:10 --> 00:00:13
To make a donation, or view
additional materials from

7
00:00:13 --> 00:00:16
hundreds of MIT courses,
visit MIT OpenCourseware

8
00:00:16 --> 00:00:17
at ocw.mit.edu.


9
00:00:17 --> 00:00:22
PROFESSOR ERIC GRIMSON: All
right, I'm going to start

10
00:00:22 --> 00:00:26
today by talking about, so
what have we been doing?

11
00:00:26 --> 00:00:28
What have we actually done
over the last few lectures?

12
00:00:28 --> 00:00:32
And I want to suggest that what
we've done is, we've outlined a

13
00:00:32 --> 00:00:35
lot of the basic elements
of programming.

14
00:00:35 --> 00:00:36
A lot of the basic elements
we're going to need

15
00:00:36 --> 00:00:37
to write code.


16
00:00:37 --> 00:00:39
And I want to just highlight it
for you because we're going

17
00:00:39 --> 00:00:40
to come back and look at it.


18
00:00:40 --> 00:00:43
So I'm going to suggest
that we've looked at three

19
00:00:43 --> 00:00:45
different kinds of things.


20
00:00:45 --> 00:00:51
We've talked about data, we've
talked about operations,

21
00:00:51 --> 00:00:59
and we've talked about
commands or statements.

22
00:00:59 --> 00:01:00
All right?


23
00:01:00 --> 00:01:01
Data's what we expect.


24
00:01:01 --> 00:01:05
It's our way of representing
fundamentally the kinds of

25
00:01:05 --> 00:01:06
information we want
to move around.

26
00:01:06 --> 00:01:11
And here, I'm going to suggest
we've seen numbers, we've seen

27
00:01:11 --> 00:01:16
strings, and I'm going to
add Booleans here as well.

28
00:01:16 --> 00:01:19
They're a third kind of value
that we saw when we started

29
00:01:19 --> 00:01:21
talking about conditions.


30
00:01:21 --> 00:01:24
We saw, associated with that
primitive data, we have ways of

31
00:01:24 --> 00:01:27
taking data in and creating new
kinds of data out, or new

32
00:01:27 --> 00:01:31
versions of data out,
so we have operations.

33
00:01:31 --> 00:01:33
Things like addition and
multiplication, which we saw

34
00:01:33 --> 00:01:36
not only apply to numbers, but
we can use them on things like

35
00:01:36 --> 00:01:38
strings and we're going to
come back to them again.

36
00:01:38 --> 00:01:40
Can't use them on Booleans,
they have a different

37
00:01:40 --> 00:01:41
set of things.


38
00:01:41 --> 00:01:45
They do things
like AND, and OR.

39
00:01:45 --> 00:01:47
And of course there's a bunch
of other ones in there, I'm not

40
00:01:47 --> 00:01:49
going to put them all up, but
we're building up a little

41
00:01:49 --> 00:01:52
collection, if you like,
of those operations.

42
00:01:52 --> 00:01:53
And then the main thing
we've done is, we've

43
00:01:53 --> 00:01:54
talked about commands.


44
00:01:54 --> 00:01:57
So I'm going to suggest we've
seen now four different things.

45
00:01:57 --> 00:02:04
We've seen assignment, how
to bind a name to a value.

46
00:02:04 --> 00:02:10
We've seen input and output.


47
00:02:10 --> 00:02:15
Print for output, for example,
and raw input for input.

48
00:02:15 --> 00:02:23
We've seen conditionals, or
said another way, branches,

49
00:02:23 --> 00:02:26
ways of changing the flow of
control through that

50
00:02:26 --> 00:02:28
sequence of instructions
we're building up.

51
00:02:28 --> 00:02:31
And the last thing we added
were loop mechanisms.

52
00:02:31 --> 00:02:40
And here we saw, wow.


53
00:02:40 --> 00:02:44
It's the first
example we've seen.

54
00:02:44 --> 00:02:46
So what've we done so far?


55
00:02:46 --> 00:02:51
Now, interestingly, this set of
instructions was actually quite

56
00:02:51 --> 00:02:53
powerful, and we're going to
come back to that later on, in

57
00:02:53 --> 00:02:56
terms of what we can do with
it, but what we've really done

58
00:02:56 --> 00:02:59
is, given that basis, we're now
talking about, how do we write

59
00:02:59 --> 00:03:02
common patterns of code, how do
we write things that solve

60
00:03:02 --> 00:03:03
particular kinds of problems.


61
00:03:03 --> 00:03:06
So what I want you to do, is to
keep in mind, those are the

62
00:03:06 --> 00:03:08
bases, we ought to be able to
do a lot with that bases, but

63
00:03:08 --> 00:03:10
what we're really interested in
is not filling out a whole

64
00:03:10 --> 00:03:13
bunch of other things in here,
but how do we put them together

65
00:03:13 --> 00:03:14
into common templates.


66
00:03:14 --> 00:03:16
And we're going to
do that today.

67
00:03:16 --> 00:03:19
Second thing we've been doing,
I want to highlight for you is,

68
00:03:19 --> 00:03:22
we've along the way, mostly
just verbally rather than

69
00:03:22 --> 00:03:27
writing it down, but we've been
talking about good style.

70
00:03:27 --> 00:03:28
Good programming style.


71
00:03:28 --> 00:03:28
All right?


72
00:03:28 --> 00:03:31
Things that we ought to do, as
you put these pieces together,

73
00:03:31 --> 00:03:33
in order to give you
really good code.

74
00:03:33 --> 00:03:34
And you should be
collecting those together.

75
00:03:34 --> 00:03:35
Give you some examples.


76
00:03:35 --> 00:03:36
What have we talked about?


77
00:03:36 --> 00:03:39
We've talked about things like
using comments to highlight

78
00:03:39 --> 00:03:42
what you're doing in the code,
to make it easier to debug.

79
00:03:42 --> 00:03:46
We talked about type
discipline, the notion that you

80
00:03:46 --> 00:03:50
should check the types of
operands before you apply

81
00:03:50 --> 00:03:52
operators to them, to make sure
that they're what the

82
00:03:52 --> 00:03:54
code is expecting.


83
00:03:54 --> 00:03:57
We talked about descriptive
use of good variable names,

84
00:03:57 --> 00:04:00
as a way, in essence, of
documenting your code.

85
00:04:00 --> 00:04:02
The fourth one we talked about
was this idea of testing all

86
00:04:02 --> 00:04:06
possible branches through a
piece of code, if it's got

87
00:04:06 --> 00:04:09
conditionals in it, to make
sure that every possible input

88
00:04:09 --> 00:04:12
is going to give you an output
that you actually want to see.

89
00:04:12 --> 00:04:14
So, you know, you can start
writing your own, kind of, Miss

90
00:04:14 --> 00:04:16
Manners book, if you like,
I mean, are what are good

91
00:04:16 --> 00:04:18
programming, you know-- I
wonder what you'd call them,

92
00:04:18 --> 00:04:20
John, good programming hygiene?


93
00:04:20 --> 00:04:21
Good programming style?


94
00:04:21 --> 00:04:23
Good programming practices?--
Things that you want to

95
00:04:23 --> 00:04:26
do to write good code.


96
00:04:26 --> 00:04:27
OK.


97
00:04:27 --> 00:04:29
What we're going to do today
is, we're going to start now

98
00:04:29 --> 00:04:32
building up, beyond just these
pieces, although they're

99
00:04:32 --> 00:04:36
valuable, to start creating two
things: one, common patterns of

100
00:04:36 --> 00:04:39
code that tackle certain
classes of problems, and

101
00:04:39 --> 00:04:42
secondly we're going to talk
about tools you can use to

102
00:04:42 --> 00:04:45
help understand those
pieces of things.

103
00:04:45 --> 00:04:46
OK.


104
00:04:46 --> 00:04:49
So last time around, we talked
about, or introduced if you

105
00:04:49 --> 00:04:52
like, iterative programs.


106
00:04:52 --> 00:05:00
And I want to generalize
that for a second, because

107
00:05:00 --> 00:05:08
we're going to come back
and use this a lot.

108
00:05:08 --> 00:05:10
And I want to do a very
high-level description of what

109
00:05:10 --> 00:05:12
goes into an iterative
program, or how I would think

110
00:05:12 --> 00:05:13
about this, all right?


111
00:05:13 --> 00:05:16
And I know if John disagrees
with me he'll tell me, but this

112
00:05:16 --> 00:05:17
is my way of thinking about it.


113
00:05:17 --> 00:05:20
If I want to try and decide how
to tackle a problem in an

114
00:05:20 --> 00:05:23
iterative matter, here the
steps I'm going to go through.

115
00:05:23 --> 00:05:31
First thing I'm going to do, is
I'm going to choose a variable

116
00:05:31 --> 00:05:36
that's going to count.


117
00:05:36 --> 00:05:37
What I meant-- what in the
world do I mean by that?

118
00:05:37 --> 00:05:39
I'm thinking about a problem,
I'm going to show you an

119
00:05:39 --> 00:05:41
example in a second, first
thing I'm going to do is say,

120
00:05:41 --> 00:05:45
what is the thing that's going
to change every time I run

121
00:05:45 --> 00:05:46
through the same set of code?


122
00:05:46 --> 00:05:48
What is counting my way
through this process?

123
00:05:48 --> 00:05:51
Now I'm putting count in double
quotes, not to make it a

124
00:05:51 --> 00:05:54
string, but to say, this
is count generically.

125
00:05:54 --> 00:05:57
It could be counting one by one
through the integers, it could

126
00:05:57 --> 00:05:59
also be taking a collection of
data and going through

127
00:05:59 --> 00:06:00
them one by one.


128
00:06:00 --> 00:06:02
It could be doing counting
in some other mechanism.

129
00:06:02 --> 00:06:05
But what's the variable
I want to use?

130
00:06:05 --> 00:06:11
Second thing I do, I
need to initialize it.

131
00:06:11 --> 00:06:16
And I need to initialize
it outside of the loop.

132
00:06:16 --> 00:06:18
That is, where do
I want to start?

133
00:06:18 --> 00:06:21
And I need to make sure I have
a command that sets that up.

134
00:06:21 --> 00:06:24
The third thing I'm going
to do, is I need to set

135
00:06:24 --> 00:06:28
up the right end test.


136
00:06:28 --> 00:06:31
How do I know when I'm
done with the loop?

137
00:06:31 --> 00:06:34
And obviously, that ought to
involve the variable in some

138
00:06:34 --> 00:06:36
way, or it's not going to make
a lot of sense, so this

139
00:06:36 --> 00:06:38
includes the variable, since
that's the thing

140
00:06:38 --> 00:06:40
that's changing.


141
00:06:40 --> 00:06:41
All right.


142
00:06:41 --> 00:06:43
The fourth thing I'm going to
do, is I'm going to then

143
00:06:43 --> 00:06:51
construct the block of code.


144
00:06:51 --> 00:06:53
And I want to remind you, that
block of code is a set of

145
00:06:53 --> 00:06:56
instructions, the same set of
instructions that are going to

146
00:06:56 --> 00:06:58
be done each time
through the loop.

147
00:06:58 --> 00:07:00
All that's going to change, is
the value the variable or the

148
00:07:00 --> 00:07:02
value of some data structures.


149
00:07:02 --> 00:07:06
And remind you that inside
of here, I'd better be

150
00:07:06 --> 00:07:10
changing the variable.


151
00:07:10 --> 00:07:12
All right, if that variable
that's counting is not

152
00:07:12 --> 00:07:15
changing, I'm going to be stuck
in an infinite loop, so I ought

153
00:07:15 --> 00:07:16
to [UNINTELLIGIBLE PHRASE]


154
00:07:16 --> 00:07:16
that


155
00:07:16 --> 00:07:19
, right, expect somewhere
in there, a change

156
00:07:19 --> 00:07:20
of that variable.


157
00:07:20 --> 00:07:21
All right?


158
00:07:21 --> 00:07:23
And then the last thing I want
to do, is just decide, you

159
00:07:23 --> 00:07:32
know, what do I do
when I'm done.

160
00:07:32 --> 00:07:33
OK.


161
00:07:33 --> 00:07:33
I know.


162
00:07:33 --> 00:07:35
It looks boring.


163
00:07:35 --> 00:07:37
But it's a structure of the
things I want to think about

164
00:07:37 --> 00:07:39
when I go through trying to
take a problem and mapping it

165
00:07:39 --> 00:07:41
into a iterative program.


166
00:07:41 --> 00:07:43
Those are the things I want
to see if I go along.

167
00:07:43 --> 00:07:44
All right.


168
00:07:44 --> 00:07:47
So let me give you an example.


169
00:07:47 --> 00:07:51
I'm given an integer that's a
perfect square, and I want to

170
00:07:51 --> 00:07:53
write a little piece of
code that's going to find

171
00:07:53 --> 00:07:54
the square root of it.


172
00:07:54 --> 00:07:56
All right, so I'm cheating a
little, I know it's a perfect

173
00:07:56 --> 00:07:58
square, somebody's given it to
me, we'll come back in a second

174
00:07:58 --> 00:08:00
to generalizing it, so what
would the steps be that I'd

175
00:08:00 --> 00:08:02
use to walk through it?


176
00:08:02 --> 00:08:04
Well if you think about
these steps, here's

177
00:08:04 --> 00:08:06
an easy way to do it.


178
00:08:06 --> 00:08:07
Let's start at 1.


179
00:08:07 --> 00:08:08
Let's call x the thing
I'm trying to find

180
00:08:08 --> 00:08:09
the square root of.


181
00:08:09 --> 00:08:10
Let's start at 1.


182
00:08:10 --> 00:08:12
Square it.


183
00:08:12 --> 00:08:16
If it's not greater
than x, take 2.

184
00:08:16 --> 00:08:17
Square it.


185
00:08:17 --> 00:08:19
If it's not greater
than x, take 3.

186
00:08:19 --> 00:08:19
Square it.


187
00:08:19 --> 00:08:22
And keep going, until the
square of one of those integers

188
00:08:22 --> 00:08:27
is greater than or equal to--
sorry, just greater than x.

189
00:08:27 --> 00:08:28
OK, why am I doing that?


190
00:08:28 --> 00:08:31
When I get greater than x,
I've gone past the place

191
00:08:31 --> 00:08:32
where I want to be.


192
00:08:32 --> 00:08:35
And obviously, when I get to
something whose square is equal

193
00:08:35 --> 00:08:38
to x, I've got the answer
I want, and I kick it out.

194
00:08:38 --> 00:08:39
So who knows what I've done?


195
00:08:39 --> 00:08:41
I've identified the thing I'm
going to use to count,

196
00:08:41 --> 00:08:43
something some variable is
going to just count the

197
00:08:43 --> 00:08:46
integers, I've identified the
end test, which is when that

198
00:08:46 --> 00:08:49
square is bigger than the thing
I'm looking for, I've

199
00:08:49 --> 00:08:52
identified basically what I
want to do inside the loop,

200
00:08:52 --> 00:08:56
which is simply keep changing
that variable, and I didn't say

201
00:08:56 --> 00:08:57
what I want to do when
I'm done, essentially

202
00:08:57 --> 00:09:00
print out the answer.


203
00:09:00 --> 00:09:01
OK, so how can I code this up?


204
00:09:01 --> 00:09:03
Well, you might think, let's
just jump in and write some

205
00:09:03 --> 00:09:05
code, I don't want to quite do
that though, because I want to

206
00:09:05 --> 00:09:07
show you another tool that's
valuable for thinking about how

207
00:09:07 --> 00:09:11
to structure the code, and that
is a something called

208
00:09:11 --> 00:09:15
a flow chart.


209
00:09:15 --> 00:09:17
Now.


210
00:09:17 --> 00:09:20
People of Professor Guttag's
and my age, unfortunately

211
00:09:20 --> 00:09:22
remember flow charts back-- as
they say, on the Simpsons, back

212
00:09:22 --> 00:09:25
in the day, back in the 1960's,
John, right?-- really good

213
00:09:25 --> 00:09:28
programmers had these wonderful
little plastic stencils, I

214
00:09:28 --> 00:09:30
tried to find one, I couldn't
find it It's a little stencil

215
00:09:30 --> 00:09:33
with little cut-out shapes on
it, that you used to draw flow

216
00:09:33 --> 00:09:35
charts, I'm going to show you
in a second, and you tucked it

217
00:09:35 --> 00:09:37
right in here next to your
pocket protector with all your

218
00:09:37 --> 00:09:40
pens in it, you know, so, your
belt was also about this high,

219
00:09:40 --> 00:09:42
and your glasses were this
thick, you know, we have a few

220
00:09:42 --> 00:09:45
of those nerds left, we mostly
keep them in the museum, but

221
00:09:45 --> 00:09:48
that was what you did
with the flow chart.

222
00:09:48 --> 00:09:49
Despite making a bad joke
about it, we're going to

223
00:09:49 --> 00:09:50
do the same thing here.


224
00:09:50 --> 00:09:50
We're going to do the same
thing here, we're going to

225
00:09:50 --> 00:09:54
chart out a little bit of
what should go into actually

226
00:09:54 --> 00:09:56
making this thing work.


227
00:09:56 --> 00:09:58
So here's a simple flow chart
that I'm going to use to

228
00:09:58 --> 00:10:01
capture what I just described.


229
00:10:01 --> 00:10:03
And I'm going to, again, I'm
actually going to do it the way

230
00:10:03 --> 00:10:09
they used to do it, and draw a
rectangle with rounded corners,

231
00:10:09 --> 00:10:12
that's my starting point, and
then what did I say to do?

232
00:10:12 --> 00:10:14
I said I need to identify a
variable, I'm going to give it

233
00:10:14 --> 00:10:17
a name, let's just call ANS,
for answer, and I need to

234
00:10:17 --> 00:10:21
initialize it, so I'm going
to come down, and in a

235
00:10:21 --> 00:10:30
square box, I'm going
to initialize ANS to 0.

236
00:10:30 --> 00:10:31
And now I want to run
through the loop.

237
00:10:31 --> 00:10:32
What's the first thing
I do in a loop?

238
00:10:32 --> 00:10:34
I test an end test.


239
00:10:34 --> 00:10:37
So the flow chart says, and the
tradition was to do this in a

240
00:10:37 --> 00:10:44
diamond shape, I'm going to
check if ANS times ANS-- oh,

241
00:10:44 --> 00:10:47
which way did I want to do
this-- is less than

242
00:10:47 --> 00:10:51
or equal to x.


243
00:10:51 --> 00:10:52
Now that's a test.


244
00:10:52 --> 00:10:54
There are two possibilities.


245
00:10:54 --> 00:11:00
If the answer is yes, then I'm
still looking for the answer,

246
00:11:00 --> 00:11:01
what do I want to do?


247
00:11:01 --> 00:11:03
Well, I don't have to
do anything other than

248
00:11:03 --> 00:11:04
change the counter.


249
00:11:04 --> 00:11:14
So I'm going to go to ANS
is ANS plus 1, and I'm

250
00:11:14 --> 00:11:17
going to do it again.


251
00:11:17 --> 00:11:22
Eventually, if I've done this
right, that test is no-- and I

252
00:11:22 --> 00:11:25
wonderfully ran out of room
here-- in which case, I'm going

253
00:11:25 --> 00:11:27
to go to a print statement,
which was always done in a

254
00:11:27 --> 00:11:32
trapezoid, and print out ANS.


255
00:11:32 --> 00:11:36
I should have put a box
below it that says stop.

256
00:11:36 --> 00:11:38
OK?


257
00:11:38 --> 00:11:40
Wow.


258
00:11:40 --> 00:11:40
And notice what I got here.


259
00:11:40 --> 00:11:43
Actually, this is a useful tool
for visualizing how I'm trying

260
00:11:43 --> 00:11:47
to put it together, because it
lets me see where the loop is,

261
00:11:47 --> 00:11:51
right there, it lets me see the
end test, it lets me make sure

262
00:11:51 --> 00:11:53
that I'm in fact initializing
the variable and I'm checking

263
00:11:53 --> 00:11:55
the right things as I go along.


264
00:11:55 --> 00:11:58
And the idea of this flow chart
is, if you start, you know, a

265
00:11:58 --> 00:12:01
little ball bearing here, it's
going to roll down, setting up

266
00:12:01 --> 00:12:03
an assignment statement, and
then, depending on here, it's

267
00:12:03 --> 00:12:05
like there's a pair of flippers
in there, it does the test, it

268
00:12:05 --> 00:12:08
sets the ball this way to
change it to ANS plus 1, and

269
00:12:08 --> 00:12:11
comes back around, eventually
it's going to drop through

270
00:12:11 --> 00:12:12
and print out the answer.


271
00:12:12 --> 00:12:15
The reason I'm going to show
you this flow chart, I'm going

272
00:12:15 --> 00:12:16
to do one other example in
a second, but I want to

273
00:12:16 --> 00:12:17
show you a comparison.


274
00:12:17 --> 00:12:19
Remember last time, we wrote
this simple piece of code

275
00:12:19 --> 00:12:21
to print out even or odd.


276
00:12:21 --> 00:12:25
If, you know, x, it was
in fact, even or odd.

277
00:12:25 --> 00:12:28
So let me show you what a flow
chart for that would look like,

278
00:12:28 --> 00:12:35
because I want to make a
comparison point here.

279
00:12:35 --> 00:12:37
If I were to do a flow
chart for that one,

280
00:12:37 --> 00:12:40
I'd do the following.


281
00:12:40 --> 00:12:49
It reminds you, that the test
here was, we took x if that's

282
00:12:49 --> 00:12:53
what we were looking for, it
did integer division by 2,

283
00:12:53 --> 00:12:56
multiplied it by 2, and we
check to see if that

284
00:12:56 --> 00:12:58
was the same as x.


285
00:12:58 --> 00:13:10
If the answer is yes, then
we did a print of even.

286
00:13:10 --> 00:13:21
If the answer was no, we
did a print of odd, and

287
00:13:21 --> 00:13:27
we then carried on.


288
00:13:27 --> 00:13:28
Again, wow.


289
00:13:28 --> 00:13:30
But there's an
important point here.

290
00:13:30 --> 00:13:32
Remember last time, I said that
there's different kinds of

291
00:13:32 --> 00:13:37
complexity in our code, and I
suggested for simple branching

292
00:13:37 --> 00:13:41
programs, the amount of time it
takes to run that program is,

293
00:13:41 --> 00:13:44
in essence, bounded by the
number of instructions, because

294
00:13:44 --> 00:13:47
you only execute each
instruction at most once.

295
00:13:47 --> 00:13:49
It didn't depend on the
size of the input.

296
00:13:49 --> 00:13:52
And you can see that there.


297
00:13:52 --> 00:13:57
I start off, either I take this
path and carry on, or I take

298
00:13:57 --> 00:14:01
that path and carry on, but
each box, if you like, gets

299
00:14:01 --> 00:14:02
touched exactly once.


300
00:14:02 --> 00:14:06
On the other hand,
look at this one.

301
00:14:06 --> 00:14:10
This depends now
on the size of x.

302
00:14:10 --> 00:14:12
All right?


303
00:14:12 --> 00:14:13
Because what am I going to do?


304
00:14:13 --> 00:14:14
I'm going to come down and
say, is ANS squared less

305
00:14:14 --> 00:14:15
than or equal to x?


306
00:14:15 --> 00:14:18
If it is, I'm going to go
around, and execute that

307
00:14:18 --> 00:14:21
statement, check it again, and
go around and execute that.

308
00:14:21 --> 00:14:25
So I'm going to cycle around
that loop there enough times to

309
00:14:25 --> 00:14:27
get to the answer, and that
number of times is going to

310
00:14:27 --> 00:14:31
depend on the input, so as I
change the input, I'm going to

311
00:14:31 --> 00:14:33
change the complexity
of the code.

312
00:14:33 --> 00:14:37
Now this happens to be what we
would call a linear process,

313
00:14:37 --> 00:14:40
because the number of times I
go around the loop is directly

314
00:14:40 --> 00:14:41
related to the size
of the argument.

315
00:14:41 --> 00:14:43
If I double the argument, I'm
going to double the number of

316
00:14:43 --> 00:14:45
times I go around the loop.


317
00:14:45 --> 00:14:47
If I increase it by five, I'm
going to increase by five the

318
00:14:47 --> 00:14:49
number of times I go
around the loop.

319
00:14:49 --> 00:14:51
We'll see later on, there are
classes of computation that are

320
00:14:51 --> 00:14:54
inherently much more complex.


321
00:14:54 --> 00:14:56
We hate them, because they're
costly, but they're sometimes

322
00:14:56 --> 00:14:57
inherently that way.


323
00:14:57 --> 00:15:01
But you can see the comparison
between these two.

324
00:15:01 --> 00:15:01
OK.


325
00:15:01 --> 00:15:07
Now, having done that,
let's build this code.

326
00:15:07 --> 00:15:11
Yeah, if my machine will
come back up, there we go.

327
00:15:11 --> 00:15:15
So, I'm going to now go ahead
and write a little piece of

328
00:15:15 --> 00:15:17
code, and I put it here and I
hope you can actually see these

329
00:15:17 --> 00:15:23
better this time, let me
uncomment that region.

330
00:15:23 --> 00:15:25
All right.


331
00:15:25 --> 00:15:27
So, there's basically
an encapsulation of

332
00:15:27 --> 00:15:29
that code, right?


333
00:15:29 --> 00:15:33
It says-- what, look at this,
where am I, right here-- I've

334
00:15:33 --> 00:15:36
got some value for x initially,
I'm going to set ANS to 0, just

335
00:15:36 --> 00:15:40
like there, and there's my
loop, there's the test, which

336
00:15:40 --> 00:15:43
is right like that, is ANS
squared less than or equal to

337
00:15:43 --> 00:15:48
x, if it is, there's the block
corresponding to the loop,

338
00:15:48 --> 00:15:50
change ANS, and eventually when
I'm done with all this thing,

339
00:15:50 --> 00:15:53
I'm just going to
print ANS out.

340
00:15:53 --> 00:15:53
OK.


341
00:15:53 --> 00:15:57
All right, let me show you one
other tool that I want to use.

342
00:15:57 --> 00:16:00
Which is, I've written
that piece of code,

343
00:16:00 --> 00:16:01
I ought to check it.


344
00:16:01 --> 00:16:04
Well, I could just run it, but
another useful thing to do is,

345
00:16:04 --> 00:16:07
I'm, especially as I want to
debug these things, is

346
00:16:07 --> 00:16:08
to simulate that code.


347
00:16:08 --> 00:16:13
And I'm going to do this
because, as Professor Guttag

348
00:16:13 --> 00:16:15
noticed to me, students
seem reluctant to do this.

349
00:16:15 --> 00:16:18
I guess it's not macho enough,
John, to just, you know, you

350
00:16:18 --> 00:16:20
know, go off and do things by
hand, you ought to just run

351
00:16:20 --> 00:16:22
them, but it's a valuable tool
to get into, so let

352
00:16:22 --> 00:16:23
me do that here.


353
00:16:23 --> 00:16:26
STUDENT: [UNINTELLIGIBLE]


354
00:16:26 --> 00:16:28
PROFESSOR ERIC GRIMSON: I'm
doing such a great job.

355
00:16:28 --> 00:16:30
I've got to say, when my, I've
got two sons, now aged eighteen

356
00:16:30 --> 00:16:32
and twenty, they used to think
I had the coolest job in

357
00:16:32 --> 00:16:34
the world because I came
home covered in chalk.

358
00:16:34 --> 00:16:36
Now they have a different
opinion that you can

359
00:16:36 --> 00:16:39
probably figure out.


360
00:16:39 --> 00:16:40
All right.


361
00:16:40 --> 00:16:41
Simulate the code.


362
00:16:41 --> 00:16:44
What I mean by that is, pick a
simple set of values, and let's

363
00:16:44 --> 00:16:46
walk through it to
see what happens.

364
00:16:46 --> 00:16:48
And this is useful because it's
going to allow me to A, make

365
00:16:48 --> 00:16:51
sure that I've got something
that's going to terminate, it's

366
00:16:51 --> 00:16:53
going to let me make sure
that in fact I'm doing the

367
00:16:53 --> 00:16:54
right kinds of updates.


368
00:16:54 --> 00:16:57
I could do this, by the way, by
running the code and putting

369
00:16:57 --> 00:16:59
print statements in various
places as well, but the hand

370
00:16:59 --> 00:17:02
simulation is valuable,
so let me just start it.

371
00:17:02 --> 00:17:03
What do I have here?


372
00:17:03 --> 00:17:10
I need the variable, ANS,
I need x, and I need ANS

373
00:17:10 --> 00:17:11
times ANS, ANS times ANS.


374
00:17:11 --> 00:17:12
Right.


375
00:17:12 --> 00:17:13
Those are the three things
that are involved in this

376
00:17:13 --> 00:17:17
computation. and I pick
something reasonably simple.

377
00:17:17 --> 00:17:19
The ANS starts at 0.


378
00:17:19 --> 00:17:22
I set up x, I think,
to be 16 there.

379
00:17:22 --> 00:17:23
So what does the loop say?


380
00:17:23 --> 00:17:24
I can either look at my
flow chart, or I can

381
00:17:24 --> 00:17:25
look at the code.


382
00:17:25 --> 00:17:28
If I look at the flow chart,
it says, I'm at this point.

383
00:17:28 --> 00:17:29
Look at ANS squared.


384
00:17:29 --> 00:17:31
Is it less than or equal to--
sorry, first of all, ANS

385
00:17:31 --> 00:17:34
squared is 0, is it less
than or equal to x, yes.

386
00:17:34 --> 00:17:35
So what do I do?


387
00:17:35 --> 00:17:36
Change ANS.


388
00:17:36 --> 00:17:39
X doesn't change.


389
00:17:39 --> 00:17:41
Back around to the test.


390
00:17:41 --> 00:17:42
What's ANS squared?


391
00:17:42 --> 00:17:43
It's 1.


392
00:17:43 --> 00:17:45
Is it less than or equal to 16?


393
00:17:45 --> 00:17:46
Sure.


394
00:17:46 --> 00:17:47
Run the loop again.


395
00:17:47 --> 00:17:49
ANS becomes 2.


396
00:17:49 --> 00:17:50
X stays 16.


397
00:17:50 --> 00:17:53
ANS squared is 4.


398
00:17:53 --> 00:17:55
Is that less than
or equal to 16?

399
00:17:55 --> 00:17:55
Yes.


400
00:17:55 --> 00:17:58
Aren't you glad I didn't
pick x equals 500?

401
00:17:58 --> 00:18:00
All right.


402
00:18:00 --> 00:18:02
ANS goes up by 0.


403
00:18:02 --> 00:18:03
ANS squared is nine.


404
00:18:03 --> 00:18:06
Still less than or equal to 16.


405
00:18:06 --> 00:18:07
ANS goes to 4.


406
00:18:07 --> 00:18:10
X stays the same.


407
00:18:10 --> 00:18:12
4 squared is 16.


408
00:18:12 --> 00:18:14
Is 16 less than or equal to 16?


409
00:18:14 --> 00:18:15
Yes.


410
00:18:15 --> 00:18:17
So ANS goes to five.


411
00:18:17 --> 00:18:19
ANS squared becomes 25.


412
00:18:19 --> 00:18:19
Ah!


413
00:18:19 --> 00:18:25
That is now no longer true
here, so I print out 5.

414
00:18:25 --> 00:18:27
Right.


415
00:18:27 --> 00:18:27
Sure.


416
00:18:27 --> 00:18:28
Square root of 16 is 5.


417
00:18:28 --> 00:18:31
It's Bush economics.


418
00:18:31 --> 00:18:33
OK?


419
00:18:33 --> 00:18:33
I know.


420
00:18:33 --> 00:18:37
I'm not supposed to make
bad jokes like that.

421
00:18:37 --> 00:18:39
What happened?


422
00:18:39 --> 00:18:39
Yeah.


423
00:18:39 --> 00:18:48
STUDENT: It doesn't stop
at the right place.

424
00:18:48 --> 00:18:49
PROFESSOR ERIC GRIMSON:
It doesn't stop at

425
00:18:49 --> 00:18:49
the right place.


426
00:18:49 --> 00:18:49
Thank you.


427
00:18:49 --> 00:18:50
Exactly.


428
00:18:50 --> 00:18:50
Right?


429
00:18:50 --> 00:18:53
My bug here is right there.


430
00:18:53 --> 00:18:58
Ah, let me find my cursor.


431
00:18:58 --> 00:19:00
I probably want that.


432
00:19:00 --> 00:19:00
Right?


433
00:19:00 --> 00:19:02
I want less than, rather
than less than or equal to.

434
00:19:02 --> 00:19:05
This is an easy bug
to come up with.

435
00:19:05 --> 00:19:07
But imagine, if you don't do
the test, you're going to get

436
00:19:07 --> 00:19:08
answers that don't
make any sense.

437
00:19:08 --> 00:19:11
And in fact, if we just go
ahead and run this now,

438
00:19:11 --> 00:19:18
hopefully we get out-- oops,
sorry, I'm going to have to

439
00:19:18 --> 00:19:21
change this quickly, I still
have some things uncommented at

440
00:19:21 --> 00:19:23
the bottom, yeah, there they
are, I don't think we need that

441
00:19:23 --> 00:19:32
yet, all right, we will
comment those out.

442
00:19:32 --> 00:19:35
OK.


443
00:19:35 --> 00:19:38
So.


444
00:19:38 --> 00:19:39
Why did I do it?


445
00:19:39 --> 00:19:41
It's a simple example, I agree,
but notice what I just did.

446
00:19:41 --> 00:19:44
It allowed me to highlight, is
the code doing the right thing?

447
00:19:44 --> 00:19:47
I spotted an error here, I
could have spotted it by

448
00:19:47 --> 00:19:49
running it on different test
sets, and using prints things,

449
00:19:49 --> 00:19:51
another way of doing it,
but this idea of at least

450
00:19:51 --> 00:19:54
simulating it on simple
examples lets you check a

451
00:19:54 --> 00:19:56
couple of important questions.


452
00:19:56 --> 00:19:58
And in fact, now let me ask
those two questions about

453
00:19:58 --> 00:20:00
this piece of code.


454
00:20:00 --> 00:20:04
First question is, for what
values of integers-- we're

455
00:20:04 --> 00:20:07
going to assume integers-- but
for what values of x does

456
00:20:07 --> 00:20:09
this code terminate?


457
00:20:09 --> 00:20:13
And the second question is, for
what values of x does it give

458
00:20:13 --> 00:20:14
me back the right answer?


459
00:20:14 --> 00:20:18
All right, first question.


460
00:20:18 --> 00:20:22
What values of x
does it terminate?

461
00:20:22 --> 00:20:26
Again, assume x is an integer.


462
00:20:26 --> 00:20:27
Well, break it
down into pieces.

463
00:20:27 --> 00:20:29
Suppose x is positive.


464
00:20:29 --> 00:20:32
Does it terminate?


465
00:20:32 --> 00:20:33
Sure.


466
00:20:33 --> 00:20:33
All right?


467
00:20:33 --> 00:20:38
Because ANS starts out as 0,
so ANS squared is 0, and

468
00:20:38 --> 00:20:41
each time through the
loop, ANS is increasing.

469
00:20:41 --> 00:20:44
That means, at some point, in
some finite number of steps,

470
00:20:44 --> 00:20:47
ANS squared has got to get
bigger than x if x is positive.

471
00:20:47 --> 00:20:50
So for positive integers,
it terminates.

472
00:20:50 --> 00:20:52
And it probably, I think
we can deduce, returns

473
00:20:52 --> 00:20:54
the right answer here.


474
00:20:54 --> 00:20:54
Right.


475
00:20:54 --> 00:20:56
X is negative.


476
00:20:56 --> 00:20:59
X is -16.


477
00:20:59 --> 00:21:05
Does this code terminate?


478
00:21:05 --> 00:21:08
Boy, I feel like Arnold
Schwarzenegger.

479
00:21:08 --> 00:21:11
Does this terminate?


480
00:21:11 --> 00:21:11
Somebody.


481
00:21:11 --> 00:21:15
STUDENT: [UNINTELLIGIBLE]


482
00:21:15 --> 00:21:15
PROFESSOR ERIC GRIMSON:
Ah, thank you, so it

483
00:21:15 --> 00:21:16
does terminate, right?


484
00:21:16 --> 00:21:19
You're sitting too far
back, let me try--

485
00:21:19 --> 00:21:21
oh, too far!-- Sorry.


486
00:21:21 --> 00:21:23
Come get me one later
if you can't find it.

487
00:21:23 --> 00:21:25
Yes, it stops at the
first step, right?

488
00:21:25 --> 00:21:26
Let's look at it.


489
00:21:26 --> 00:21:30
It says, if answer, sorry,
imagine x is -16, ANS is 0,

490
00:21:30 --> 00:21:35
is 0 less than -16, no.


491
00:21:35 --> 00:21:37
So what does it do?


492
00:21:37 --> 00:21:39
It prints out 0.


493
00:21:39 --> 00:21:40
Ah!


494
00:21:40 --> 00:21:43
So that now answers my second
question, it does terminate,

495
00:21:43 --> 00:21:46
but does it give me
the right answer?

496
00:21:46 --> 00:21:47
No.


497
00:21:47 --> 00:21:47
Right?


498
00:21:47 --> 00:21:49
It gives me an answer, and
imagine I'm using this

499
00:21:49 --> 00:21:52
somewhere else, you know, it's
going to go off and say, gee,

500
00:21:52 --> 00:21:54
the square root of -16 is 0.


501
00:21:54 --> 00:21:56
Well, it really should be a,
you know, an imaginary number,

502
00:21:56 --> 00:21:59
but this is not a valuable
thing to have come back.

503
00:21:59 --> 00:22:01
So that's the second thing I've
just highlighted here, is that

504
00:22:01 --> 00:22:05
I now have the ability to
check whether it does

505
00:22:05 --> 00:22:06
the right thing.


506
00:22:06 --> 00:22:09
And those are two things that
you'd like to do with every

507
00:22:09 --> 00:22:11
looping construct you write:
you'd like to be able to assure

508
00:22:11 --> 00:22:15
yourself that they will always
terminate, and then the second

509
00:22:15 --> 00:22:17
thing you'd like to do, is to
assure yourself that it

510
00:22:17 --> 00:22:19
does give you back a
reasonable answer.

511
00:22:19 --> 00:22:21
We started to talk about
ways to do the former.

512
00:22:21 --> 00:22:22
It's looking at the end test.


513
00:22:22 --> 00:22:24
It's looking at the kinds
of conditions you're

514
00:22:24 --> 00:22:25
going to put in.


515
00:22:25 --> 00:22:28
For the latter, this is a place
where running test cases

516
00:22:28 --> 00:22:31
would do a good job
of helping with that.

517
00:22:31 --> 00:22:34
Nonetheless, having done
that, let's look at a

518
00:22:34 --> 00:22:35
better way to write this.


519
00:22:35 --> 00:22:40
Which is right here, it is
also, I think, on your sheet,

520
00:22:40 --> 00:22:47
I'm going to uncomment that,
and comment this one out, yeah.

521
00:22:47 --> 00:22:50
All right?


522
00:22:50 --> 00:22:53
So let's look at this
code for a second.

523
00:22:53 --> 00:22:54
Notice what this does.


524
00:22:54 --> 00:22:57
Certainly the heart of
it, right in here, is

525
00:22:57 --> 00:22:59
still the same thing.


526
00:22:59 --> 00:23:00
But notice what this does.


527
00:23:00 --> 00:23:03
The first thing it does is, it
says, let's check and make sure

528
00:23:03 --> 00:23:05
x is greater than
or equal to 0.

529
00:23:05 --> 00:23:07
If it isn't, notice
what's going to happen.

530
00:23:07 --> 00:23:10
None of that block is going to
get executed, and it's going to

531
00:23:10 --> 00:23:13
come down here and print out a
useful piece of information,

532
00:23:13 --> 00:23:15
which says, hey, you gave
me a negative number.

533
00:23:15 --> 00:23:17
I don't know how to do this.


534
00:23:17 --> 00:23:20
If it is, in fact, positive,
then we're going to go

535
00:23:20 --> 00:23:21
in here, but now notice
what we're doing here.

536
00:23:21 --> 00:23:23
There is the basic thing
we did before, right?

537
00:23:23 --> 00:23:26
We're checking the end test and
incrementing, actually I was

538
00:23:26 --> 00:23:28
going to, I commented that out
for a reason you'll see in a

539
00:23:28 --> 00:23:30
second, but I, normally I would
keep this on, which would let

540
00:23:30 --> 00:23:33
me, at each step, see
what it's doing.

541
00:23:33 --> 00:23:35
If I ran this, it would
print out each step.

542
00:23:35 --> 00:23:37
Which is helping me make
sure that it's incrementing

543
00:23:37 --> 00:23:38
the right way.


544
00:23:38 --> 00:23:41
OK, once it gets to the end of
that, what's it going to do?

545
00:23:41 --> 00:23:44
It's going to come
down here and, oh.

546
00:23:44 --> 00:23:46
What's that doing?


547
00:23:46 --> 00:23:47
Well, I cheated when I started.


548
00:23:47 --> 00:23:49
I said, somebody's giving me a
perfect square, I'm looking

549
00:23:49 --> 00:23:51
for the square root of it.


550
00:23:51 --> 00:23:55
But suppose I gave this thing
15, and asked it to run.

551
00:23:55 --> 00:23:56
It'd still give me an answer.


552
00:23:56 --> 00:23:59
It just would not be the
answer I'm looking for.

553
00:23:59 --> 00:24:02
So now, in this case, this code
is going to, when we get here,

554
00:24:02 --> 00:24:04
check, and if you haven't seen
that strange thing there, that

555
00:24:04 --> 00:24:08
exclamation point in
computer-ese called a bang, it

556
00:24:08 --> 00:24:14
says if ANS star ANS is not
equal to x, all right?

557
00:24:14 --> 00:24:15
What's that say, it says, I've
already gotten to the end of

558
00:24:15 --> 00:24:17
the loop, I'm now past where I
wanted to be, and I'm going to

559
00:24:17 --> 00:24:19
check to make sure that, in
fact, this really is

560
00:24:19 --> 00:24:20
a perfect square.


561
00:24:20 --> 00:24:23
If it isn't, print out
something says, ah, you gave

562
00:24:23 --> 00:24:25
me something that wasn't
a perfect square.

563
00:24:25 --> 00:24:32
And only if that is true, am I
going to print out the answer.

564
00:24:32 --> 00:24:34
It's the same computation.


565
00:24:34 --> 00:24:37
But this is a nice way of
writing it, often called

566
00:24:37 --> 00:24:47
defensive programming.


567
00:24:47 --> 00:24:49
And I think we have lots of
variations on it-- I don't know

568
00:24:49 --> 00:24:51
about John, what your favorite
is, for the definition of

569
00:24:51 --> 00:24:54
defensive programming-- for me
it says, make sure that I'm

570
00:24:54 --> 00:24:57
going through all possible
paths through the code, make

571
00:24:57 --> 00:25:00
sure I'm printing out, or
returning if you like, useful

572
00:25:00 --> 00:25:03
information for each style,
sorry, for each path through

573
00:25:03 --> 00:25:06
the code, make sure that for
all possible inputs there is a

574
00:25:06 --> 00:25:09
path through the code, or a way
to get through the code, that

575
00:25:09 --> 00:25:11
does not cause an error
or infinite loop.

576
00:25:11 --> 00:25:12
What else would you add, John?


577
00:25:12 --> 00:25:17
PROFESSOR JOHN GUTTAG: Well,
we'll come back to this later

578
00:25:17 --> 00:25:21
in the term, and talk in some
detail about particular

579
00:25:21 --> 00:25:22
techniques.


580
00:25:22 --> 00:25:26
The basic idea of defensive
programming is, to assume that

581
00:25:26 --> 00:25:29
A, if you're getting inputs
from a user, they won't

582
00:25:29 --> 00:25:32
necessarily give you the input
you've asked for, so if you ask

583
00:25:32 --> 00:25:34
for a positive number, don't
count on them giving you one,

584
00:25:34 --> 00:25:39
and B, if you're using a piece
of a program written by a

585
00:25:39 --> 00:25:44
programmer who is not perfect,
perhaps yourself, there could

586
00:25:44 --> 00:25:48
be mistakes in that program,
and so you write your program

587
00:25:48 --> 00:25:51
under the assumption that, not
only might the user make a

588
00:25:51 --> 00:25:54
mistake, other parts of your
program might make a mistake,

589
00:25:54 --> 00:25:58
and you just put in lots of
different tests under the

590
00:25:58 --> 00:26:01
assumption that you'd rather
catch that something has gone

591
00:26:01 --> 00:26:04
wrong, then have it go
wrong and not know it.

592
00:26:04 --> 00:26:07
And we'll talk later in the
term about dozens of different

593
00:26:07 --> 00:26:10
tricks, but the main thing to
keep in mind is the general

594
00:26:10 --> 00:26:14
principle that people are dumb.


595
00:26:14 --> 00:26:16
And will make mistakes.


596
00:26:16 --> 00:26:19
And therefore, you write your
programs so that catastrophes

597
00:26:19 --> 00:26:22
don't occur when those
mistakes are made.

598
00:26:22 --> 00:26:24
PROFESSOR ERIC GRIMSON: Good.


599
00:26:24 --> 00:26:26
As John said, we're going
to come back to it.

600
00:26:26 --> 00:26:28
But that's what,
basically the goal here.

601
00:26:28 --> 00:26:30
And you saw me put my hands up
when I said stupid programmer?

602
00:26:30 --> 00:26:33
I've certainly written code
that has this problem, I've

603
00:26:33 --> 00:26:36
tried to use my own code that
has this problem, and good to

604
00:26:36 --> 00:26:40
us, right, good hygiene, I'm
going to use that word again

605
00:26:40 --> 00:26:42
here, of getting into the habit
of writing defensive code up

606
00:26:42 --> 00:26:44
front, it's part of that
collection of things that

607
00:26:44 --> 00:26:46
you ought to do, is
a great thing to do.

608
00:26:46 --> 00:26:49
I stress it in particular
because, I know you're all

609
00:26:49 --> 00:26:52
going to get into this stage;
you've got a problem set due in

610
00:26:52 --> 00:26:55
a couple of hours, you're still
writing the code, you don't

611
00:26:55 --> 00:26:58
want to waste time, and I'm
going to use quotes on "waste

612
00:26:58 --> 00:27:00
time", doing those extra
things to do the defensive

613
00:27:00 --> 00:27:03
programming, you just want to
get the darn thing done.

614
00:27:03 --> 00:27:05
It's a bad habit to get into,
because when you come back

615
00:27:05 --> 00:27:07
to it, it may haunt you
later on down the road.

616
00:27:07 --> 00:27:09
So really get into that notion
of trying to be defensive

617
00:27:09 --> 00:27:11
as you program.


618
00:27:11 --> 00:27:12
OK.


619
00:27:12 --> 00:27:16
The other thing I want to say
here, is that this style of

620
00:27:16 --> 00:27:18
program we just wrote, is
actually a very common one.

621
00:27:18 --> 00:27:26
And we're going to give
it a nice little name,

622
00:27:26 --> 00:27:29
often referred to as
exhaustive enumeration.

623
00:27:29 --> 00:27:30
What does that mean?


624
00:27:30 --> 00:27:35
It says, I'm literally walking
through all possible values of

625
00:27:35 --> 00:27:38
some parameter, some element of
the computation, testing

626
00:27:38 --> 00:27:40
everything until I find
the right answer.

627
00:27:40 --> 00:27:43
All right, so it's, you know,
again, I can even write that

628
00:27:43 --> 00:27:55
down, essentially saying, try
all reasonable values until

629
00:27:55 --> 00:28:02
you find the solution.


630
00:28:02 --> 00:28:03
And you might say, well, wait
a minute, isn't that going

631
00:28:03 --> 00:28:05
to be really expensive?


632
00:28:05 --> 00:28:07
And the answer is, yeah, I
guess, if you want to search,

633
00:28:07 --> 00:28:10
you know, all the pages on
Google, one by one, yes,

634
00:28:10 --> 00:28:12
probably, it's going
to take a while.

635
00:28:12 --> 00:28:14
But there are an awful lot of
computations for which this

636
00:28:14 --> 00:28:15
is the right way to do it.


637
00:28:15 --> 00:28:17
You just want to exhaustively
go through things.

638
00:28:17 --> 00:28:19
And just to give you a
sense of that, let me

639
00:28:19 --> 00:28:20
show you an example.


640
00:28:20 --> 00:28:25
I'm going to change
this, all right?

641
00:28:25 --> 00:28:30
Nice big number.


642
00:28:30 --> 00:28:32
You know, computers
are fast these days.

643
00:28:32 --> 00:28:33
I can make this even bigger,
it's going to do it fairly

644
00:28:33 --> 00:28:35
quickly, so it really
is quick to do this.

645
00:28:35 --> 00:28:38
It doesn't mean that exhaustive
enumeration is a bad idea, it

646
00:28:38 --> 00:28:40
is often the right idea to use.


647
00:28:40 --> 00:28:43
So we've seen one example of
this, this idea of walking

648
00:28:43 --> 00:28:46
through all the integers
looking for the square root.

649
00:28:46 --> 00:28:48
Let's look at some other
examples, in order to try

650
00:28:48 --> 00:28:52
and see other ways in
which we could do it.

651
00:28:52 --> 00:28:52
OK.


652
00:28:52 --> 00:28:56
In particular, let's go over
to here, and let me show

653
00:28:56 --> 00:28:58
you a second example.


654
00:28:58 --> 00:29:07
And let me comment that out.


655
00:29:07 --> 00:29:11
Here's another problem
that I'd like to solve.

656
00:29:11 --> 00:29:13
Suppose I want to find all the
divisors of some integer, I

657
00:29:13 --> 00:29:17
want to figure out what all
the divisors are that

658
00:29:17 --> 00:29:19
go evenly into it.


659
00:29:19 --> 00:29:21
Again, same kind of reasoning
says, given some value x, I

660
00:29:21 --> 00:29:23
happened to pick a small one
here, what's an easy

661
00:29:23 --> 00:29:24
way to do this?


662
00:29:24 --> 00:29:27
Well, let's just start at one.


663
00:29:27 --> 00:29:29
That's my variable I'm
going to change and check.

664
00:29:29 --> 00:29:32
Does it divide evenly into x?


665
00:29:32 --> 00:29:33
If it does, print it out.


666
00:29:33 --> 00:29:35
Move on to the next
one, print it out.

667
00:29:35 --> 00:29:37
So again, I can do the same
kind of thing here, you can see

668
00:29:37 --> 00:29:40
that, in fact, let's just run
it to make sure it does

669
00:29:40 --> 00:29:44
the right thing, OK?


670
00:29:44 --> 00:29:47
In fact, if I go back to
the code, what did I

671
00:29:47 --> 00:29:48
decide to do here?


672
00:29:48 --> 00:29:52
I say, starting with an
initialization of I, there's my

673
00:29:52 --> 00:29:55
first step, as equal to 1, I'm
going to walk through a little

674
00:29:55 --> 00:29:58
loop where I check, as long--
first of all, as long as I is

675
00:29:58 --> 00:29:59
less than x, so there's my
end test, I'm going

676
00:29:59 --> 00:30:00
to do something.


677
00:30:00 --> 00:30:02
And in this case, the something
is, I'm going to look to

678
00:30:02 --> 00:30:06
see if I divides x evenly.


679
00:30:06 --> 00:30:08
So I'll remind you of that
amp-- sorry, that percent sign

680
00:30:08 --> 00:30:12
there, that says if x divided
by I has a 0 remainder, because

681
00:30:12 --> 00:30:14
this gives me back the
remainder, if that's equal to

682
00:30:14 --> 00:30:16
0, print something out.


683
00:30:16 --> 00:30:19
And there's my nice increment.


684
00:30:19 --> 00:30:20
Simple little piece of code.


685
00:30:20 --> 00:30:23
Notice again, exactly the same
form: I picked the thing I

686
00:30:23 --> 00:30:26
wanted to vary, I initialized
it outside the loop, I have a

687
00:30:26 --> 00:30:29
test to see when I'm done, and
then I've got a set of

688
00:30:29 --> 00:30:31
instructions I'm doing every
time inside the loop.

689
00:30:31 --> 00:30:33
In this case, it's doing
the check on the remainder

690
00:30:33 --> 00:30:34
and printing them out.


691
00:30:34 --> 00:30:36
And when I'm done with the
whole thing, before I end the

692
00:30:36 --> 00:30:39
increment of the variable, you
know, when I'm done, I'm just

693
00:30:39 --> 00:30:42
not returning anything out.


694
00:30:42 --> 00:30:42
OK.


695
00:30:42 --> 00:30:45
So now you've seen
two simple examples.

696
00:30:45 --> 00:30:47
Let me generalize this.


697
00:30:47 --> 00:30:51
In this case, my incrementer
was just adding 1 to an

698
00:30:51 --> 00:30:54
integer, it's a pretty
straightforward thing to do.

699
00:30:54 --> 00:30:55
But you can imagine thinking
about this a little

700
00:30:55 --> 00:30:56
differently.


701
00:30:56 --> 00:30:59
If I somehow had a collection,
an ordered collection of all

702
00:30:59 --> 00:31:04
the integers, from 1 to 10, I
could imagine doing the same

703
00:31:04 --> 00:31:06
thing, where now what I'm doing
is, I'm starting with the first

704
00:31:06 --> 00:31:08
element of that collection,
doing something, going to the

705
00:31:08 --> 00:31:10
next element, doing something,
going to the next element,

706
00:31:10 --> 00:31:12
doing something, I'm just
walking through the

707
00:31:12 --> 00:31:12
sequence of elements.


708
00:31:12 --> 00:31:14
Right?


709
00:31:14 --> 00:31:16
And I haven't said yet, how do
I get that collection, but you

710
00:31:16 --> 00:31:18
could certainly conceptualize
that, if I had that collection,

711
00:31:18 --> 00:31:21
that would be nice thing to do.


712
00:31:21 --> 00:31:23
That is a more common pattern.


713
00:31:23 --> 00:31:28
That is basically saying, given
some collection of data, I want

714
00:31:28 --> 00:31:30
to have again a looping
mechanism, where now my process

715
00:31:30 --> 00:31:33
is, walk through this,
the collection, one

716
00:31:33 --> 00:31:33
element at a time.


717
00:31:33 --> 00:31:41
And for that, we have a
particular construct,

718
00:31:41 --> 00:31:42
called a FOR loop.


719
00:31:42 --> 00:31:44
It's going to do
exactly that for us.

720
00:31:44 --> 00:31:46
It's going to be more general
than this, and we're going to

721
00:31:46 --> 00:31:48
come back to that, in fact,
Professor Guttag's going to

722
00:31:48 --> 00:31:50
pick this up in a couple of
lectures, but we can talk right

723
00:31:50 --> 00:31:51
now about the basic form.


724
00:31:51 --> 00:31:55
The form of a FOR loop says,
FOR, and I'm going to put

725
00:31:55 --> 00:31:57
little angle braces in here
again, to say, for some

726
00:31:57 --> 00:32:08
variable, like a name I want to
get to it, in some collection,

727
00:32:08 --> 00:32:14
and then I have a
block of code.

728
00:32:14 --> 00:32:17
And what it's saying
semantically is, using that

729
00:32:17 --> 00:32:20
variable as my placeholder,
have it walk through this

730
00:32:20 --> 00:32:23
collection, starting at the
first thing, execute that code,

731
00:32:23 --> 00:32:26
then the next thing, execute
that code, and so on.

732
00:32:26 --> 00:32:30
One of the advantages of this
is, that I don't have to

733
00:32:30 --> 00:32:33
worry about explicitly
updating my variable.

734
00:32:33 --> 00:32:35
That happens for
me automatically.

735
00:32:35 --> 00:32:38
And that's very nice, because
this allows me to be sure

736
00:32:38 --> 00:32:39
that my FOR loop is
going to terminate.

737
00:32:39 --> 00:32:44
And because, as long as this
collection is finite, this

738
00:32:44 --> 00:32:45
thing is just going
to walk through.

739
00:32:45 --> 00:32:46
All right?


740
00:32:46 --> 00:32:49
So, if I show you, for example,
I'm going to comment this one

741
00:32:49 --> 00:32:58
out in the usual manner, and
let's look at uncommenting

742
00:32:58 --> 00:33:07
that, there is the
same piece of code.

743
00:33:07 --> 00:33:09
Now, I slung something by you,
or snuck something by you,

744
00:33:09 --> 00:33:13
which is, I hadn't said how
to generate the set of

745
00:33:13 --> 00:33:14
integers from 1 to 10.


746
00:33:14 --> 00:33:17
So, range is a built-in
Python function.

747
00:33:17 --> 00:33:18
I'm going to come back
to it in a second.

748
00:33:18 --> 00:33:21
For now, just think of it as
saying, it gives you all the

749
00:33:21 --> 00:33:25
integers from 1 up to,
but not including, x.

750
00:33:25 --> 00:33:26
OK.


751
00:33:26 --> 00:33:27
But now you can see the form.


752
00:33:27 --> 00:33:30
This now says, OK, let I start
as the first thing in there,

753
00:33:30 --> 00:33:33
which is 1, and then do exactly
as I did before, the same

754
00:33:33 --> 00:33:36
thing, but notice I don't need
to say how to increment it.

755
00:33:36 --> 00:33:38
It's happening
automatically for me.

756
00:33:38 --> 00:33:40
OK.


757
00:33:40 --> 00:33:45
In fact, if I run it, it
does the same thing, which

758
00:33:45 --> 00:33:47
is what I would expect.


759
00:33:47 --> 00:33:49
OK.


760
00:33:49 --> 00:33:53
Now, the advantage of the
FOR, as I said, is that it

761
00:33:53 --> 00:33:57
has, then, if you like, a
cleaner way of reading it.

762
00:33:57 --> 00:34:00
I don't have to worry about, do
I initialize it, did I forget

763
00:34:00 --> 00:34:02
to initialize it outside the
loop, it happens automatically

764
00:34:02 --> 00:34:05
just by the syntax of it, right
there, that's going to start

765
00:34:05 --> 00:34:06
with the first element.


766
00:34:06 --> 00:34:07
I don't have to worry about,
did I remember to put the

767
00:34:07 --> 00:34:09
incrementer in, it's going to
automatically walk it's

768
00:34:09 --> 00:34:11
way through there.


769
00:34:11 --> 00:34:13
Second advantage of the FOR
is, that right now, we're

770
00:34:13 --> 00:34:15
thinking about it just as
a sequence of integers.

771
00:34:15 --> 00:34:17
We could imagine it's just
counting its way through.

772
00:34:17 --> 00:34:19
But we're going to see, very
shortly, that in fact those

773
00:34:19 --> 00:34:22
collections could be arbitrary.


774
00:34:22 --> 00:34:24
We're going to have other ways
of building them, but it could

775
00:34:24 --> 00:34:25
be a collection of
all the primes.

776
00:34:25 --> 00:34:26
Hm.


777
00:34:26 --> 00:34:27
There's an interesting
thing to do.

778
00:34:27 --> 00:34:30
It could be a collection of,
ah, you know, I don't know,

779
00:34:30 --> 00:34:32
batting averages of
somebody or other.

780
00:34:32 --> 00:34:34
It could be arbitrary
collections that you've come

781
00:34:34 --> 00:34:35
up with in other ways.


782
00:34:35 --> 00:34:38
The FOR is, again, going to let
you walk through that thing.

783
00:34:38 --> 00:34:40
So it does not have to be
something that could be

784
00:34:40 --> 00:34:44
described procedurally,
such as add 1 just to

785
00:34:44 --> 00:34:45
the previous element.


786
00:34:45 --> 00:34:47
It could be any
arbitrary collection.

787
00:34:47 --> 00:34:49
And if I were to use that
again, I'd just put it on your

788
00:34:49 --> 00:34:51
handout, I could go back and
rewrite that thing that I had

789
00:34:51 --> 00:34:54
previously for finding the
square roots of the perfect

790
00:34:54 --> 00:34:57
squares, just using
the FOR loop.

791
00:34:57 --> 00:34:59
OK.


792
00:34:59 --> 00:35:01
What I want to do, though, is
go on to-- or, sorry, go back

793
00:35:01 --> 00:35:06
to-- my divisor example.


794
00:35:06 --> 00:35:07
[UNINTELLIGIBLE PHRASE]


795
00:35:07 --> 00:35:07
OK.


796
00:35:07 --> 00:35:08
Try again.


797
00:35:08 --> 00:35:09
I've got a number, I want
to find the divisors.

798
00:35:09 --> 00:35:11
Right now, what my code is
doing is, it's printing them

799
00:35:11 --> 00:35:14
up for me, which is useful.


800
00:35:14 --> 00:35:17
But imagine I actually wanted
to gather them together.

801
00:35:17 --> 00:35:20
I wanted to collect them, so I
could do something with them.

802
00:35:20 --> 00:35:21
I might want to add them up.


803
00:35:21 --> 00:35:22
Might want to multiply
them together.

804
00:35:22 --> 00:35:24
Might want to do, I don't know,
something else with them, find

805
00:35:24 --> 00:35:27
common divisors, of things
by looking at them.

806
00:35:27 --> 00:35:30
I need, in fact, a way to make
explicit, what I can't do that

807
00:35:30 --> 00:35:34
with range, is I need a way
to collect things together.

808
00:35:34 --> 00:35:37
And that's going to be the
first of our more compound data

809
00:35:37 --> 00:35:40
structures, and we have exactly
such a structure, and

810
00:35:40 --> 00:35:49
it's called a tuple.


811
00:35:49 --> 00:36:00
This is an ordered
sequence of elements.

812
00:36:00 --> 00:36:02
Now, I'm going to actually add
something to it that's going to

813
00:36:02 --> 00:36:05
make sense in a little while,
or in a couple of lectures,

814
00:36:05 --> 00:36:09
which is, it is immutable.


815
00:36:09 --> 00:36:11
Meaning, I cannot change it,
and we'll see why that's

816
00:36:11 --> 00:36:12
important later on.


817
00:36:12 --> 00:36:17
But for now, tuple is this
ordered sequence of structures.

818
00:36:17 --> 00:36:18
OK.


819
00:36:18 --> 00:36:20
And how do I create them?


820
00:36:20 --> 00:36:32
Well, the representation is,
following a square bracket,

821
00:36:32 --> 00:36:34
followed by a sequence of
elements, separated by

822
00:36:34 --> 00:36:38
commas, followed by a
closed square bracket.

823
00:36:38 --> 00:36:40
And that is literally what
I said, it is an ordered

824
00:36:40 --> 00:36:44
sequence of elements, you
can see where they are.

825
00:36:44 --> 00:36:44
OK?


826
00:36:44 --> 00:36:46
So, let me do a little
example of this.

827
00:36:46 --> 00:37:00
If I go back over here, let's
define-- er, can't type-- I can

828
00:37:00 --> 00:37:03
look at the value of test,
it's an ordered sequence.

829
00:37:03 --> 00:37:05
I need to get
elements out of it.

830
00:37:05 --> 00:37:07
So again, I have a
way of doing that.

831
00:37:07 --> 00:37:12
In particular, I can ask for
the zeroth element of test.

832
00:37:12 --> 00:37:16
OK, notice, I'm putting a
square bracket around it, and

833
00:37:16 --> 00:37:19
it gives me-- I know this
sounds confusing, but this is

834
00:37:19 --> 00:37:21
a long tradition, it
gives me-- ah, yes.

835
00:37:21 --> 00:37:24
STUDENT: [UNINTELLIGIBLE]


836
00:37:24 --> 00:37:32
PROFESSOR ERIC GRIMSON: Sorry?


837
00:37:32 --> 00:37:32
STUDENT: [UNINTELLIGIBLE]


838
00:37:32 --> 00:37:33
PROFESSOR ERIC GRIMSON:
I created a list here?

839
00:37:33 --> 00:37:35
Ah, thank you.


840
00:37:35 --> 00:37:37
I'm glad you guys
are on top of it.

841
00:37:37 --> 00:37:40
You're saying I want that.


842
00:37:40 --> 00:37:43
Is that right, John?


843
00:37:43 --> 00:37:43
Yes?


844
00:37:43 --> 00:37:44
OK.


845
00:37:44 --> 00:37:46
Sorry.


846
00:37:46 --> 00:37:47
You're going to see why
this was a mistake

847
00:37:47 --> 00:37:48
in a little while.


848
00:37:48 --> 00:37:50
I did not want to make a list,
I wanted to create a tuple

849
00:37:50 --> 00:37:51
thank you for catching it.


850
00:37:51 --> 00:37:54
I want parens, not
square brackets there.

851
00:37:54 --> 00:37:56
You'll also see in a little
while why both of these things

852
00:37:56 --> 00:37:58
would work this way, but
it's not what I wanted.

853
00:37:58 --> 00:37:59
OK?


854
00:37:59 --> 00:38:01
So I guess I should go
back, and let me do this

855
00:38:01 --> 00:38:09
correctly this way.


856
00:38:09 --> 00:38:13
Again, I can look at test, and
I guess test now if I want to

857
00:38:13 --> 00:38:18
get the element out-- angle
bracket or square bracket?

858
00:38:18 --> 00:38:21
I still want square bracket,
that's what I thought-- OK.

859
00:38:21 --> 00:38:23
Now I can go back to where I
was, which is a strange

860
00:38:23 --> 00:38:27
piece of history, which is,
we start counting at 0.

861
00:38:27 --> 00:38:31
So the-- I hate to say it this
way, the first element of this

862
00:38:31 --> 00:38:34
tuple is at position 0, or
index 0, OK?-- so I can get the

863
00:38:34 --> 00:38:40
zeroth one out, I can get, if I
do 2, I get the third thing

864
00:38:40 --> 00:38:45
out, because it goes 0, 1, 2--
notice, however, if I do

865
00:38:45 --> 00:38:50
something that tries to go
outside the length of the tuple

866
00:38:50 --> 00:38:53
it complains, which is right.


867
00:38:53 --> 00:38:55
Tuples? also have another nice
structure, which is, I can go

868
00:38:55 --> 00:38:58
the other direction, which is,
if I want to get the last

869
00:38:58 --> 00:39:03
element of that tuple I
give it a negative index.

870
00:39:03 --> 00:39:05
So, imagine, you think of it
as, is it starting right, just

871
00:39:05 --> 00:39:08
before the beginning of the
thing, if I give it a 0 it's

872
00:39:08 --> 00:39:09
going to take the first one, if
I give it a 1, it's going to

873
00:39:09 --> 00:39:12
take the next one, but I can go
the other direction, if I give

874
00:39:12 --> 00:39:15
it a -1, it picks up the
last element of the tuple.

875
00:39:15 --> 00:39:21
And again, I can
go -2, go back.

876
00:39:21 --> 00:39:27
So this is what we
would call selection.

877
00:39:27 --> 00:39:32
We can do things like
foo of 0 to get out the

878
00:39:32 --> 00:39:34
particular element.


879
00:39:34 --> 00:39:38
I can also pick up
pieces of that tuple.

880
00:39:38 --> 00:39:40
Again I want to show
you the format here.

881
00:39:40 --> 00:39:46
If I give it this strange
expression, this is saying I

882
00:39:46 --> 00:39:49
want to get the piece of the
tuple starting at index 1, it's

883
00:39:49 --> 00:39:52
going to be the second element,
and going up to but not

884
00:39:52 --> 00:39:53
including index 3.


885
00:39:53 --> 00:39:58
And it gives me
back that piece.

886
00:39:58 --> 00:40:02
Actually a copy of that
piece of the tuple.

887
00:40:02 --> 00:40:13
This is called slicing.


888
00:40:13 --> 00:40:15
And then just to complete this.


889
00:40:15 --> 00:40:18
Two other nice things you can
do with slices are you can

890
00:40:18 --> 00:40:22
get the beginning or
the end of tuple.

891
00:40:22 --> 00:40:25
So, for example, if I say TEST
and I don't give it a start but

892
00:40:25 --> 00:40:28
I give it an end, then it gives
me all the elements

893
00:40:28 --> 00:40:30
up to that point.


894
00:40:30 --> 00:40:37
And I can obviously do the
other direction which is I

895
00:40:37 --> 00:40:42
can say skip to index 2 and
all the remaining pieces.

896
00:40:42 --> 00:40:46
This lets me slice out, if you
like, the front part or back

897
00:40:46 --> 00:40:50
part or a middle part of
the tuple as I go along.

898
00:40:50 --> 00:40:52
What in the world does
that have to do with

899
00:40:52 --> 00:40:55
my divisor example?


900
00:40:55 --> 00:40:57
Well, actually, before I
do that let me in fact

901
00:40:57 --> 00:40:57
fill in a piece here.


902
00:40:57 --> 00:41:00
Which is remember I said range
we could think of conceptually

903
00:41:00 --> 00:41:07
as a tuple -- or sorry as a
sequence of these things.

904
00:41:07 --> 00:41:10
In fact it gives me back, now
I hate this, it's actually

905
00:41:10 --> 00:41:12
a list it's not a tuple.


906
00:41:12 --> 00:41:15
But for now think of it as
giving you back an explicit

907
00:41:15 --> 00:41:18
version of that representation
of all those elements.

908
00:41:18 --> 00:41:20
You'll see why I'm going to
make that distinction in

909
00:41:20 --> 00:41:22
a couple of lectures.


910
00:41:22 --> 00:41:23
All right.


911
00:41:23 --> 00:41:25
What does this have to do
with my divisor example?

912
00:41:25 --> 00:41:28
This says I can make tuples,
but imagine now going back

913
00:41:28 --> 00:41:31
to my divisor example and
I want to gather up the

914
00:41:31 --> 00:41:33
elements as I go along.


915
00:41:33 --> 00:41:36
I ought to be able to do
that by in fact just

916
00:41:36 --> 00:41:38
adding the pieces in.


917
00:41:38 --> 00:41:42
And that's what I'm
going to do over here.

918
00:41:42 --> 00:41:56
Which is, let me comment that
out, let me uncomment that.

919
00:41:56 --> 00:41:58
And I guess I need the
same thing here, right?

920
00:41:58 --> 00:42:04
I need parens not, thank you.


921
00:42:04 --> 00:42:06
You can tell I'm an
old time list packer.

922
00:42:06 --> 00:42:08
I really do love these things.


923
00:42:08 --> 00:42:15
And is that right, John?


924
00:42:15 --> 00:42:17
OK, so my apologies that
your handout is wrong.

925
00:42:17 --> 00:42:18
I did not think to check
about the difference

926
00:42:18 --> 00:42:20
between these things.


927
00:42:20 --> 00:42:22
Nonetheless, having done
that, let's look at

928
00:42:22 --> 00:42:24
what I'm going to do.


929
00:42:24 --> 00:42:27
I now want to run a loop
where I need to collect

930
00:42:27 --> 00:42:28
things together.


931
00:42:28 --> 00:42:29
I'm going to give
a name to that.

932
00:42:29 --> 00:42:31
And what you see there is
I'm going to call divisors

933
00:42:31 --> 00:42:35
initially an empty tuple,
something has nothing in it.

934
00:42:35 --> 00:42:36
Right here.


935
00:42:36 --> 00:42:38
And then I'm going to run
through the same loop as

936
00:42:38 --> 00:42:40
before, going through this set
of things, doing the check.

937
00:42:40 --> 00:42:42
Now what I'd like to do, every
time I find a divisor I'd

938
00:42:42 --> 00:42:44
like to gather it together.


939
00:42:44 --> 00:42:49
So I'm going to create a tuple
of one element, the value of i.

940
00:42:49 --> 00:42:51
And then, ah, cool.


941
00:42:51 --> 00:42:54
Here's that addition operation
that's badly overloaded.

942
00:42:54 --> 00:42:56
This is why Professor
Guttag likes and I don't.

943
00:42:56 --> 00:43:01
Because given that this is a
tuple and that's a tuple, I

944
00:43:01 --> 00:43:02
can just add them together.


945
00:43:02 --> 00:43:06
That is concatenate them, if
you like, one on the end of it.

946
00:43:06 --> 00:43:09
And if I keep doing that, when
I'm done divisor will be

947
00:43:09 --> 00:43:10
a collection of things.


948
00:43:10 --> 00:43:15
So let me just run it.


949
00:43:15 --> 00:43:17
All right.


950
00:43:17 --> 00:43:21
This is what I get
for trying to --

951
00:43:21 --> 00:43:22
STUDENT There should be
a comment after the

952
00:43:22 --> 00:43:22
i in parentheses.


953
00:43:22 --> 00:43:24
PROFESSOR ERIC
GRIMSON: Thank you.

954
00:43:24 --> 00:43:26
Right there.


955
00:43:26 --> 00:43:31
All right, we'll
try this again.

956
00:43:31 --> 00:43:36
OK.


957
00:43:36 --> 00:43:37
And there are the
set of devices.

958
00:43:37 --> 00:43:37
Thank you.


959
00:43:37 --> 00:43:38
Who did that?


960
00:43:38 --> 00:43:41
Somebody gets, no?


961
00:43:41 --> 00:43:41
Yours?


962
00:43:41 --> 00:43:42
Thank you.


963
00:43:42 --> 00:43:44
Nice catch too by the way.


964
00:43:44 --> 00:43:46
All right, so now that you
can see that I can screw up

965
00:43:46 --> 00:43:47
programming, which I just did.


966
00:43:47 --> 00:43:49
But we fixed it on the fly.


967
00:43:49 --> 00:43:49
Thank you.


968
00:43:49 --> 00:43:51
What have we done?


969
00:43:51 --> 00:43:53
We've now got a way
of collecting things

970
00:43:53 --> 00:43:55
together, right?


971
00:43:55 --> 00:43:58
And this is the first version
of something we'd like to use.

972
00:43:58 --> 00:44:00
Now that I've gotten that bound
as a name, I could go in

973
00:44:00 --> 00:44:01
and do things with that.


974
00:44:01 --> 00:44:05
I could go in and say give me
the fourth divisor, give me the

975
00:44:05 --> 00:44:06
second through fifth divisor.


976
00:44:06 --> 00:44:09
Again as I suggested if I've
got two integers and I want

977
00:44:09 --> 00:44:11
to find common divisors I
could take those two lists

978
00:44:11 --> 00:44:11
and walk through them.


979
00:44:11 --> 00:44:13
I shouldn't say list, those two
tuples, and walk through them

980
00:44:13 --> 00:44:15
to find the pieces
that match up.

981
00:44:15 --> 00:44:19
So I've got a way now of
gathering data together.

982
00:44:19 --> 00:44:21
The last thing I want to do is
to say all right, now that

983
00:44:21 --> 00:44:26
we've got this idea of being
able to collect things into

984
00:44:26 --> 00:44:29
collections, we've got the
ability now to use looping

985
00:44:29 --> 00:44:33
structures as we did before but
we can walk down then doing

986
00:44:33 --> 00:44:37
things to them, where else
might we have this need to do

987
00:44:37 --> 00:44:40
things with looping structures?


988
00:44:40 --> 00:44:43
And I'm going to suggest
you've already seen it.

989
00:44:43 --> 00:44:45
What's a string?


990
00:44:45 --> 00:44:49
Well at some level it is an
ordered sequence of characters.

991
00:44:49 --> 00:44:51
Right?


992
00:44:51 --> 00:44:53
Now it is not represented
this same way.

993
00:44:53 --> 00:44:55
You don't see strings
inside these open parens

994
00:44:55 --> 00:44:56
and closed parens.


995
00:44:56 --> 00:45:00
You don't see strings with
commas between them, but it has

996
00:45:00 --> 00:45:01
the same kind of property.


997
00:45:01 --> 00:45:04
It is in ordered
sequence of characters.

998
00:45:04 --> 00:45:07
We'd like to do the same
thing with strings.

999
00:45:07 --> 00:45:09
That is we'd like to be able
to get pieces of them out.

1000
00:45:09 --> 00:45:11
We'd like to be able add them
together or concatenate

1001
00:45:11 --> 00:45:11
them together.


1002
00:45:11 --> 00:45:13
We'd like to be able
to slice them.

1003
00:45:13 --> 00:45:17
And in fact we can.


1004
00:45:17 --> 00:45:33
So strings also support things
like selection, slicing, and a

1005
00:45:33 --> 00:45:35
set of other parameters,
other properties.

1006
00:45:35 --> 00:45:36
And let's just look at that.


1007
00:45:36 --> 00:45:47
Again if I go back here,
let me comment this out.

1008
00:45:47 --> 00:45:49
Right here are a pair
of strings that I've

1009
00:45:49 --> 00:45:55
set up, s 1 and s 2.


1010
00:45:55 --> 00:45:57
Let me just run these.


1011
00:45:57 --> 00:46:00
We can go back over here.


1012
00:46:00 --> 00:46:03
So I can see the value
of s 1, it's a string.

1013
00:46:03 --> 00:46:07
I can do things
like s 1 and s 2.

1014
00:46:07 --> 00:46:09
As we saw before, it simply
concatenates them together and

1015
00:46:09 --> 00:46:11
gives me back a longer string.


1016
00:46:11 --> 00:46:13
But I can also ask
for parts of this.

1017
00:46:13 --> 00:46:20
So I can, for example, say
give me the first element

1018
00:46:20 --> 00:46:23
of string 1, s 1.


1019
00:46:23 --> 00:46:26
Ah, that's exactly what we
would have thought if this was

1020
00:46:26 --> 00:46:29
represented as an ordered
sequence of things.

1021
00:46:29 --> 00:46:32
Again I should have said first,
index 0, the first one.

1022
00:46:32 --> 00:46:38
I can similarly go in and
say I'd like all the things

1023
00:46:38 --> 00:46:41
between index 2 and index 4.


1024
00:46:41 --> 00:46:42
And again, remember
what that does.

1025
00:46:42 --> 00:46:44
Index 2 says start a 0.


1026
00:46:44 --> 00:46:44
1, 2.


1027
00:46:44 --> 00:46:47
So a, b, c.


1028
00:46:47 --> 00:46:49
And then it goes up to but not
including index 4 so it gets

1029
00:46:49 --> 00:46:53
c and d and then it stops.


1030
00:46:53 --> 00:46:57
I can similarly, just as I did
with the tuples, I can ask for

1031
00:46:57 --> 00:47:02
everything up to some point or
I can ask for everything

1032
00:47:02 --> 00:47:06
starting at some point
and carrying on.

1033
00:47:06 --> 00:47:09
Now what you're seeing here
then is the beginning of

1034
00:47:09 --> 00:47:11
complex data structures.


1035
00:47:11 --> 00:47:14
And the nice thing is
that there's a shared

1036
00:47:14 --> 00:47:14
behavior there.


1037
00:47:14 --> 00:47:17
Just as I can have tuples as an
ordered collection of things,

1038
00:47:17 --> 00:47:20
strings behave as an ordered
collection of things.

1039
00:47:20 --> 00:47:23
So I can start thinking about
doing manipulation on strings.

1040
00:47:23 --> 00:47:26
I can concatenate them
together, I can find pieces

1041
00:47:26 --> 00:47:28
inside of them, I could
actually do things with them.

1042
00:47:28 --> 00:47:30
And let me show you just a
simple little example of

1043
00:47:30 --> 00:47:35
something I might want to do.


1044
00:47:35 --> 00:47:42
Suppose I take, I better
comment this one out or

1045
00:47:42 --> 00:47:44
it's going to spit it out.


1046
00:47:44 --> 00:47:47
Let me comment that out.


1047
00:47:47 --> 00:47:50
Suppose I take a number.


1048
00:47:50 --> 00:47:53
I'd like to add up all the
digits inside of the number.

1049
00:47:53 --> 00:47:55
I can use the tools
I've just described in

1050
00:47:55 --> 00:47:56
order to capture that.


1051
00:47:56 --> 00:47:57
So what would I want to do?


1052
00:47:57 --> 00:47:59
I'd like to somehow walk down
each of the digits one at

1053
00:47:59 --> 00:48:02
a time and add them up.


1054
00:48:02 --> 00:48:04
Ah, that's a looping
mechanism, right?

1055
00:48:04 --> 00:48:06
I need to have some way
of walking through them.

1056
00:48:06 --> 00:48:09
An easy way to do it would
be inside of a FOR.

1057
00:48:09 --> 00:48:10
And what would I like to do?


1058
00:48:10 --> 00:48:12
Well I need to take that
number and I'm going to

1059
00:48:12 --> 00:48:13
turn it into a string.


1060
00:48:13 --> 00:48:16
So notice what I'm going
to do right here.

1061
00:48:16 --> 00:48:19
I take that number and
convert it into a string.

1062
00:48:19 --> 00:48:22
That's an example of that type
conversion we did earlier on.

1063
00:48:22 --> 00:48:25
By doing that it makes
it possible for me to

1064
00:48:25 --> 00:48:27
treat it as an ordered
sequence of characters.

1065
00:48:27 --> 00:48:29
And so what's the
loop going to do?

1066
00:48:29 --> 00:48:31
It's going to say FOR c,
which was my name for the

1067
00:48:31 --> 00:48:32
character in that string.


1068
00:48:32 --> 00:48:34
That means starting at
the first one, I'm going

1069
00:48:34 --> 00:48:35
to do something to it.


1070
00:48:35 --> 00:48:37
And what am I'm going to do?


1071
00:48:37 --> 00:48:39
I'm going to take that
character, convert it back

1072
00:48:39 --> 00:48:44
into an integer, and add
it into some digits.

1073
00:48:44 --> 00:48:46
And I've done a little short
hand here, which is I should

1074
00:48:46 --> 00:48:50
have said some digits is equal
to some digits plus this.

1075
00:48:50 --> 00:48:52
But that little short hand
there is doing exactly

1076
00:48:52 --> 00:48:52
the same thing.


1077
00:48:52 --> 00:48:55
It is adding that value into
some digits and putting

1078
00:48:55 --> 00:48:57
it back or signing it
back into some digits.

1079
00:48:57 --> 00:49:00
And I'll walk through that loop
and when I'm done I can print

1080
00:49:00 --> 00:49:04
out the total thing does.


1081
00:49:04 --> 00:49:10
And if I do that, I get
out what I would expect.

1082
00:49:10 --> 00:49:12
So what have I done?


1083
00:49:12 --> 00:49:16
We've now generalized the
idea of iteration into

1084
00:49:16 --> 00:49:17
this little pattern.


1085
00:49:17 --> 00:49:19
Again as I said this is my
version of it, but you can see,

1086
00:49:19 --> 00:49:22
every one of the examples we've
used so far has that

1087
00:49:22 --> 00:49:23
pattern to it.


1088
00:49:23 --> 00:49:24
Figure out what I'm
trying to walk through.

1089
00:49:24 --> 00:49:26
What's the collection of things
I'm trying to walk through.

1090
00:49:26 --> 00:49:28
Figure out what I want
to do at each stage.

1091
00:49:28 --> 00:49:29
Figure out what
the end test is.

1092
00:49:29 --> 00:49:31
Figure out what I'm going
to do at the end of it.

1093
00:49:31 --> 00:49:32
I can write it explicitly.


1094
00:49:32 --> 00:49:34
I can write it inside
of a FOR loop.

1095
00:49:34 --> 00:49:37
And we've started to add, and
we'll see a lot more of this,

1096
00:49:37 --> 00:49:41
examples of collections of
structures so that we don't

1097
00:49:41 --> 00:49:43
just have to do something that
can be easily described as

1098
00:49:43 --> 00:49:45
walking through a set of things
but can actually be

1099
00:49:45 --> 00:49:47
a collection that
you walk through.

1100
00:49:47 --> 00:49:53
The last thing I want to point
out to you is, I started

1101
00:49:53 --> 00:49:54
out with this list.


1102
00:49:54 --> 00:49:58
I haven't added anything
to the list, right?

1103
00:49:58 --> 00:50:01
I mean I've got a different
kind of looping mechanism.

1104
00:50:01 --> 00:50:02
I guess I should say
that's not quite true.

1105
00:50:02 --> 00:50:04
I've added the ability
to have more complex

1106
00:50:04 --> 00:50:06
data structures here.


1107
00:50:06 --> 00:50:09
But I dropped a hint in the
first lecture about what you

1108
00:50:09 --> 00:50:09
could computer with things.


1109
00:50:09 --> 00:50:13
In fact if you think for a
second about that list, you

1110
00:50:13 --> 00:50:15
could ask what can I compute
with just that set

1111
00:50:15 --> 00:50:17
of constructs?


1112
00:50:17 --> 00:50:19
And the answer is
basically anything.

1113
00:50:19 --> 00:50:22
This is an example of what is
referred to frequently as being

1114
00:50:22 --> 00:50:26
a Turing complete language.


1115
00:50:26 --> 00:50:29
That is to say with just those
set of constructs, anything you

1116
00:50:29 --> 00:50:32
can describe algorithmically
you can compute with

1117
00:50:32 --> 00:50:34
that set of constructs.


1118
00:50:34 --> 00:50:36
So there's good
news and bad news.

1119
00:50:36 --> 00:50:38
The good news is it
sounds like we're done.

1120
00:50:38 --> 00:50:41
Class is cancelled until final
exam because this is all

1121
00:50:41 --> 00:50:43
you need to know, right?


1122
00:50:43 --> 00:50:44
The bad news is of
course that's not true.

1123
00:50:44 --> 00:50:48
The real issue is to figure out
how to build constructs out of

1124
00:50:48 --> 00:50:50
this that tackle particular
problems, but the fundamental

1125
00:50:50 --> 00:50:53
basics of computation are
just captured in that

1126
00:50:53 --> 00:50:55
set of mechanisms.


1127
00:50:55 --> 00:50:57
All right, we'll
see you next time.

1128
00:50:57 --> 00:50:59




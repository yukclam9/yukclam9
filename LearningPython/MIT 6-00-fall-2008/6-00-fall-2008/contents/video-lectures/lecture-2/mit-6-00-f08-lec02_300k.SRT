1
00:00:00 --> 00:00:00



2
00:00:00 --> 00:00:02
The following content is
provided under a Creative

3
00:00:02 --> 00:00:03
Commons license.


4
00:00:03 --> 00:00:06
Your support will help MIT
OpenCourseware continue to

5
00:00:06 --> 00:00:10
offer high-quality educational
resources for free.

6
00:00:10 --> 00:00:13
To make a donation, or view
additional materials from

7
00:00:13 --> 00:00:17
hundreds of MIT courses,
visit MIT OpenCourseware,

8
00:00:17 --> 00:00:19
at ocw.mit.edu.


9
00:00:19 --> 00:00:24
PROFESSOR:
OK, to work.

10
00:00:24 --> 00:00:27
A word of warning:
fasten your seat belts.

11
00:00:27 --> 00:00:29
Or, another way of saying it
is, I'm going to open up the

12
00:00:29 --> 00:00:31
fire hose a little bit today.


13
00:00:31 --> 00:00:34
Last lecture, you might have
thought this was a SHASS class,

14
00:00:34 --> 00:00:36
it's not like a philosophy
class, and it was important to

15
00:00:36 --> 00:00:38
set the stage for what we're
going to talk about, but

16
00:00:38 --> 00:00:41
we talked about very
high level things.

17
00:00:41 --> 00:00:43
The notion of recipes, the
notion of computation, why

18
00:00:43 --> 00:00:45
you want to do this, what
you're going to learn.

19
00:00:45 --> 00:00:48
Today we're going to dive into
the nitty-gritty, the nuts and

20
00:00:48 --> 00:00:51
bolts of the basics of
computation, and in particular,

21
00:00:51 --> 00:00:53
what I'm going to do today is,
I'm going to talk about

22
00:00:53 --> 00:00:56
operators and operands, which
we did a little bit real last

23
00:00:56 --> 00:00:59
time, in particular how to
create expressions, I'm going

24
00:00:59 --> 00:01:02
to talk about statements as the
key building blocks for writing

25
00:01:02 --> 00:01:06
code, and I'm going to
introduce simple sets of

26
00:01:06 --> 00:01:09
programs, in particular I'm
going to talk about branching,

27
00:01:09 --> 00:01:11
conditionals, and iteration.


28
00:01:11 --> 00:01:12
So, a lot to do.


29
00:01:12 --> 00:01:13
OK?


30
00:01:13 --> 00:01:16
So, let me jump straight to it.


31
00:01:16 --> 00:01:18
At the end of last lecture, we
started introducing some of

32
00:01:18 --> 00:01:19
the pieces you want to do.


33
00:01:19 --> 00:01:20
And I want to remind
you of our goal.

34
00:01:20 --> 00:01:22
We're trying to
describe processes.

35
00:01:22 --> 00:01:24
We want to have things
that deduce new kinds

36
00:01:24 --> 00:01:25
of information.


37
00:01:25 --> 00:01:28
So we want to write
programs to do that.

38
00:01:28 --> 00:01:29
If we're going to write
programs, we need at least

39
00:01:29 --> 00:01:32
two things: we need some
representation for

40
00:01:32 --> 00:01:34
fundamental data.


41
00:01:34 --> 00:01:37
And we saw last time
two examples of that.

42
00:01:37 --> 00:01:39
And the second thing we're
going to need, is we're going

43
00:01:39 --> 00:01:43
to need a way to give
instructions to the computer

44
00:01:43 --> 00:01:44
to manipulate that data.


45
00:01:44 --> 00:01:47
We need to give it a
description of the recipe.

46
00:01:47 --> 00:01:53
In terms of primitive
data, what we saw were

47
00:01:53 --> 00:01:56
two kinds: Right?


48
00:01:56 --> 00:02:00
Numbers and strings.


49
00:02:00 --> 00:02:04
A little later on in the
lecture we're going to

50
00:02:04 --> 00:02:08
introduce a third kind of
value, but what we're going to

51
00:02:08 --> 00:02:11
see throughout the term is, no
matter how complex a data

52
00:02:11 --> 00:02:13
structure we create, and we're
going to create a variety of

53
00:02:13 --> 00:02:16
data structures, fundamentally
all of them have their basis,

54
00:02:16 --> 00:02:19
their atomic level if you
like, are going to be some

55
00:02:19 --> 00:02:22
combinations of numbers, of
strings, and the third type,

56
00:02:22 --> 00:02:23
which are booleans, which I'm
going to introduce a little

57
00:02:23 --> 00:02:25
later on in this lecture.


58
00:02:25 --> 00:02:27
And that kind of
makes sense right?

59
00:02:27 --> 00:02:29
Numbers are there to do numeric
things, strings are our

60
00:02:29 --> 00:02:31
fundamental way of representing
textual information.

61
00:02:31 --> 00:02:33
And so we're going to see
how to combine those

62
00:02:33 --> 00:02:35
things as we go along.


63
00:02:35 --> 00:02:38
Second thing we saw was, we saw
that associated with every

64
00:02:38 --> 00:02:41
primitive value was a type.


65
00:02:41 --> 00:02:42
And these are kind
of obvious, right?

66
00:02:42 --> 00:02:44
Strings are strings.


67
00:02:44 --> 00:02:46
For numbers, we had some
variations; we had

68
00:02:46 --> 00:02:48
integers, we had floats.


69
00:02:48 --> 00:02:49
We'll introduce a few
more as we go along.

70
00:02:49 --> 00:02:52
But those types are important,
because they tell us something

71
00:02:52 --> 00:02:55
about what we want to do when
we want to put them together.

72
00:02:55 --> 00:02:58
OK, but nonetheless, I want
to stress we have both a

73
00:02:58 --> 00:03:05
value, yeah, and a type.


74
00:03:05 --> 00:03:05
All right.


75
00:03:05 --> 00:03:07
Once we have them, we want to
start making combinations

76
00:03:07 --> 00:03:08
out of them.


77
00:03:08 --> 00:03:10
We want to put pieces together.


78
00:03:10 --> 00:03:19
And for that, we combine
things in expressions.

79
00:03:19 --> 00:03:28
And what we saw as expressions
are formed of operands

80
00:03:28 --> 00:03:30
and operators.


81
00:03:30 --> 00:03:34
And the simple things we did
were the sort of things you'd

82
00:03:34 --> 00:03:36
expect from numerical things.


83
00:03:36 --> 00:03:39
Now I want to stress
one other nuance here.

84
00:03:39 --> 00:03:41
Which is, and we're going to
do some examples of this,

85
00:03:41 --> 00:03:43
initially we just typed in
expressions into the

86
00:03:43 --> 00:03:46
interpreter; that is,
directly into Python.

87
00:03:46 --> 00:03:48
And as I suggested last time,
the interpreter is actually a

88
00:03:48 --> 00:03:52
program inside of the machine
that is basically following the

89
00:03:52 --> 00:03:54
rules we're describing here to
deduce the value

90
00:03:54 --> 00:03:55
and print it up.


91
00:03:55 --> 00:03:58
And if we type directly into
the interpreter, it essentially

92
00:03:58 --> 00:03:59
does an eval and a print.


93
00:03:59 --> 00:04:07
It evaluates, and it prints.


94
00:04:07 --> 00:04:10
Most of the time, we're going
to be doing expressions inside

95
00:04:10 --> 00:04:13
of some piece of code, inside
of a script, which is the

96
00:04:13 --> 00:04:15
Python word for program.


97
00:04:15 --> 00:04:17
In there, I want to make this
distinction, this nuance: the

98
00:04:17 --> 00:04:20
evaluator is still going to be
taking those expressions and

99
00:04:20 --> 00:04:23
using its rules to get a value,
but it's not going to

100
00:04:23 --> 00:04:24
print them back out.


101
00:04:24 --> 00:04:25
Why?


102
00:04:25 --> 00:04:27
Because typically, you're doing
that to use it somewhere

103
00:04:27 --> 00:04:28
else in the program.


104
00:04:28 --> 00:04:30
It's going to be stored
away in a variable.

105
00:04:30 --> 00:04:31
It's going to be stuck
in a data structure.

106
00:04:31 --> 00:04:34
It's going to be used
for a side effect.

107
00:04:34 --> 00:04:40
So, inside of code, or inside
of a script, there's no print,

108
00:04:40 --> 00:04:45
unless we make it explicit.


109
00:04:45 --> 00:04:47
And that's a little bit down
in the weeds, it's a detail,

110
00:04:47 --> 00:04:48
but one I want to stress.


111
00:04:48 --> 00:04:50
You need to, if you want
something to be printed out

112
00:04:50 --> 00:04:54
inside your code, you need to
tell the machine to do that.

113
00:04:54 --> 00:04:56
OK.


114
00:04:56 --> 00:04:57
So let's do some
simple examples.

115
00:04:57 --> 00:04:58
We've already seen somebody's.


116
00:04:58 --> 00:05:02
I just want to remind you, if I
wanted to, for example, type in

117
00:05:02 --> 00:05:05
an expression like that, notice
the syntactical form, it's an

118
00:05:05 --> 00:05:08
expression, a number, followed
by an operand, followed

119
00:05:08 --> 00:05:09
by another expression.


120
00:05:09 --> 00:05:12
And of course I get out
the value I'd like there.

121
00:05:12 --> 00:05:15
Yes sir.


122
00:05:15 --> 00:05:17
Oh, you don't like leaning
that far to the left?

123
00:05:17 --> 00:05:20
OK, if you're a Republican
I'll be happy to shift

124
00:05:20 --> 00:05:22
this over a little bit.


125
00:05:22 --> 00:05:23
Wow, John, I got a laugh
for a political joke,

126
00:05:23 --> 00:05:24
I'm in big trouble.


127
00:05:24 --> 00:05:26
That better?


128
00:05:26 --> 00:05:32
Oh damn, all right, I'll
have to do it even more.

129
00:05:32 --> 00:05:35
OK, here we go, here we go, you
see, I'm doing it down here, I

130
00:05:35 --> 00:05:37
can't see it, does that-- ah, I
hear his sighs of

131
00:05:37 --> 00:05:38
relief, OK, good.


132
00:05:38 --> 00:05:39
There we go.


133
00:05:39 --> 00:05:40
Better.


134
00:05:40 --> 00:05:41
All right.


135
00:05:41 --> 00:05:42
One of the other things we
showed last time is that

136
00:05:42 --> 00:05:44
operators are overloaded.


137
00:05:44 --> 00:05:46
And this is where you heard
John and I disagree.

138
00:05:46 --> 00:05:49
I don't happen to like this,
but he thinks it's an ok thing.

139
00:05:49 --> 00:05:54
In a particular-- if we, whoa,
we don't do that, we do this--

140
00:05:54 --> 00:05:57
that is, give a combination of
a number multiplication in a

141
00:05:57 --> 00:06:01
string, this will in fact give
us back a new string with that

142
00:06:01 --> 00:06:03
many replicas, if you like, of
the string concatenated

143
00:06:03 --> 00:06:05
together.


144
00:06:05 --> 00:06:05
All right?


145
00:06:05 --> 00:06:08
And if you want to do other
things, for example, we can

146
00:06:08 --> 00:06:10
take two strings and add--
whoops, sorry-- and add them

147
00:06:10 --> 00:06:16
together, we will get out,
again, a concatenation

148
00:06:16 --> 00:06:17
of that string.


149
00:06:17 --> 00:06:19
And these will, we'll let you
work through the variations,

150
00:06:19 --> 00:06:21
but these are the simple
expressions we can use.

151
00:06:21 --> 00:06:25
Now, sometimes things get
a little interesting.

152
00:06:25 --> 00:06:27
All right?


153
00:06:27 --> 00:06:33
What's the value of
that expression?

154
00:06:33 --> 00:06:38
What do you think should happen
if I evaluate that expression?

155
00:06:38 --> 00:06:38
Somebody with a hand
up, so I can see it.

156
00:06:38 --> 00:06:39
What's going to happen?


157
00:06:39 --> 00:06:41
STUDENT: [UNINTELLIGIBLE]


158
00:06:41 --> 00:06:43
PROFESSOR JIM
ERICSON: An error?

159
00:06:43 --> 00:06:43
Why?


160
00:06:43 --> 00:06:48
STUDENT: [UNINTELLIGIBLE]


161
00:06:48 --> 00:06:50
PROFESSOR JIM ERICSON: Great.


162
00:06:50 --> 00:06:50
OK.


163
00:06:50 --> 00:06:51
That means, let's check it.


164
00:06:51 --> 00:06:52
It certainly is.


165
00:06:52 --> 00:06:53
We bribe people.


166
00:06:53 --> 00:06:57
So I, ah, by the way, John's a
Yankees fan, he throws like

167
00:06:57 --> 00:06:59
Johnny Damon, I'm a Red Sox
fan, so we'll see if

168
00:06:59 --> 00:07:00
I, how about that?


169
00:07:00 --> 00:07:03
And I almost hit John
along the way, great.

170
00:07:03 --> 00:07:05
My third right, exactly,
what can I say?

171
00:07:05 --> 00:07:07
All right, so we're into
bribing you as we go along

172
00:07:07 --> 00:07:08
here, and all right?


173
00:07:08 --> 00:07:11
You'll be badly overweight
by the end of the term.

174
00:07:11 --> 00:07:13
Right, it's a syntactic error,
because it doesn't know

175
00:07:13 --> 00:07:14
how to deal with this.


176
00:07:14 --> 00:07:16
But there's an important thing
going on here, if I in fact

177
00:07:16 --> 00:07:19
wanted to combine those into a
string, I should have told the

178
00:07:19 --> 00:07:23
machine to do that, and I can
do that, by explicitly saying,

179
00:07:23 --> 00:07:27
take that, which is a number,
and convert it into a string,

180
00:07:27 --> 00:07:31
and then-- bleah, I keep doing
that-- then add it

181
00:07:31 --> 00:07:33
to that string.


182
00:07:33 --> 00:07:35
OK, so there's an
important point here.

183
00:07:35 --> 00:07:44
We've got what's called
type conversion.

184
00:07:44 --> 00:07:48
That is, if I want to combine
two things together in a

185
00:07:48 --> 00:07:51
particular way, I need to
make sure that I give it the

186
00:07:51 --> 00:07:53
kind of operand it expects.


187
00:07:53 --> 00:07:57
So STR, which I just typed up
there, takes in parens, some

188
00:07:57 --> 00:08:01
input, and it converts it into
a string, so that now I can

189
00:08:01 --> 00:08:02
use that where I was
expecting a string.

190
00:08:02 --> 00:08:03
John.


191
00:08:03 --> 00:08:07
PROFESSOR JOHN GUTTAG: You've
got a static semantic

192
00:08:07 --> 00:08:07
error in your syntax.


193
00:08:07 --> 00:08:08
PROFESSOR JIM
ERICSON: Thank you.

194
00:08:08 --> 00:08:10
And I was going to come to that
in a second, but thank you,

195
00:08:10 --> 00:08:11
John, for pointing it out.


196
00:08:11 --> 00:08:12
All right.


197
00:08:12 --> 00:08:15
Why is it a static
semantic error?

198
00:08:15 --> 00:08:18
The syntax is OK in the sense
of, it is an operand, an

199
00:08:18 --> 00:08:23
operator, an operand, so
syntactically it's OK.

200
00:08:23 --> 00:08:26
The semantics was what caused
the problem, because the

201
00:08:26 --> 00:08:28
operator was expecting a
particular kind of

202
00:08:28 --> 00:08:30
structure there.


203
00:08:30 --> 00:08:32
There's a second thing going on
here that I want to highlight,

204
00:08:32 --> 00:08:36
because it's really important.


205
00:08:36 --> 00:08:37
Yes indeed.


206
00:08:37 --> 00:08:38
OK, there we go.


207
00:08:38 --> 00:08:41
The second thing I want to
highlight is, that what's

208
00:08:41 --> 00:08:48
going on, is that Python is
doing some type checking.

209
00:08:48 --> 00:08:51
It caught the error, because
it checked the types of the

210
00:08:51 --> 00:08:54
operands before it applied
things, and it says,

211
00:08:54 --> 00:08:55
I'm going to stop.


212
00:08:55 --> 00:08:57
Now, you might have said, gee,
why didn't it just assume that

213
00:08:57 --> 00:08:59
I wanted to in fact treat
these as strings, and

214
00:08:59 --> 00:09:01
combine them together?


215
00:09:01 --> 00:09:03
Sounds like a reasonable
thing to do.

216
00:09:03 --> 00:09:05
But it's a dangerous thing.


217
00:09:05 --> 00:09:08
Because in doing that, Python
would then have a value that it

218
00:09:08 --> 00:09:10
could pass on into some other
part of a computation, and if

219
00:09:10 --> 00:09:14
it wasn't what I wanted, I
might be a long ways downstream

220
00:09:14 --> 00:09:17
in the computation before I
actually hit some result

221
00:09:17 --> 00:09:18
that makes no sense.


222
00:09:18 --> 00:09:21
And tracing back where it came
from can be really hard.

223
00:09:21 --> 00:09:23
So I actually want to have
type checking as much

224
00:09:23 --> 00:09:26
as I can early on.


225
00:09:26 --> 00:09:28
And in fact, under type
checking, different languages

226
00:09:28 --> 00:09:36
sometimes fall on a spectrum
from weak to strong typing.

227
00:09:36 --> 00:09:39
Which basically says, how much
type checking do they do?

228
00:09:39 --> 00:09:42
Now, you're going to hear John
and I go back and forth a lot,

229
00:09:42 --> 00:09:44
as I said I'm an old time--
well I'm certainly old

230
00:09:44 --> 00:09:46
time, but I'm also an old
time Lisp programmer.

231
00:09:46 --> 00:09:49
I love Lisp, but Lisp is
certainly in the category of a

232
00:09:49 --> 00:09:50
very weakly typed language.


233
00:09:50 --> 00:09:53
It does not check the types
of its arguments at all.

234
00:09:53 --> 00:09:55
Python is, I wouldn't say
completely strong, but it's

235
00:09:55 --> 00:09:58
much closer to the strong
end of the spectrum.

236
00:09:58 --> 00:10:00
It's going to do a lot of type
checking for you before it

237
00:10:00 --> 00:10:03
actually passes things back.


238
00:10:03 --> 00:10:06
Nonetheless, I'm also going to
argue that it's probably not as

239
00:10:06 --> 00:10:08
strongly typed as
we might like.

240
00:10:08 --> 00:10:13
So, for example,
there's an expression.

241
00:10:13 --> 00:10:15
Now, less than is just, if you
haven't used it before, it's

242
00:10:15 --> 00:10:17
just the operator you'd expect,
it's comparing two things and

243
00:10:17 --> 00:10:19
it's going to return either
true or false depending on

244
00:10:19 --> 00:10:23
whether the first argument is
less than the second argument.

245
00:10:23 --> 00:10:24
What's going to happen here?


246
00:10:24 --> 00:10:28
Again, I need a hand so I can
know where to throw candy.

247
00:10:28 --> 00:10:29
I've also got on my reading
glasses on, I can't

248
00:10:29 --> 00:10:31
see anything.


249
00:10:31 --> 00:10:33
Anybody.


250
00:10:33 --> 00:10:36
TAs don't count, they
get their own candy.

251
00:10:36 --> 00:10:37
When it, yep.


252
00:10:37 --> 00:10:39
STUDENT: [INAUDIBLE]


253
00:10:39 --> 00:10:40
PROFESSOR JIM ERICSON:
Good question.

254
00:10:40 --> 00:10:41
Sounds like a reasonable
guess, right?

255
00:10:41 --> 00:10:44
How in the world am I going to
compare a string to a number?

256
00:10:44 --> 00:10:46
So, see how good my
aim is, ah, not bad.

257
00:10:46 --> 00:10:47
All right.


258
00:10:47 --> 00:10:51
A good quest-- sorry, a
good thought, but in

259
00:10:51 --> 00:10:53
fact, son of a gun.


260
00:10:53 --> 00:10:58
Or as my younger son would
say, fudge knuckle.

261
00:10:58 --> 00:10:58
Yeah.


262
00:10:58 --> 00:10:59
All right?


263
00:10:59 --> 00:11:01
So, what in the world's
going on here?

264
00:11:01 --> 00:11:03
This is a place-- I don't know
about you, John, I think this

265
00:11:03 --> 00:11:07
is actually really not good,
because right, what this is

266
00:11:07 --> 00:11:10
doing is, it's allowing--
sorry, let me back up and say

267
00:11:10 --> 00:11:14
it-- it's got an overload on
the less-than that allows you

268
00:11:14 --> 00:11:17
to compare basically the
lexicographic ordering, or this

269
00:11:17 --> 00:11:20
sequence of ordering of
symbols, including numbers

270
00:11:20 --> 00:11:22
inside of the machine.


271
00:11:22 --> 00:11:24
And this, in my mind,
should have been an error.

272
00:11:24 --> 00:11:26
Why in the world would you
want to compare that?

273
00:11:26 --> 00:11:29
Just to give you an example of
that, for instance, I can do

274
00:11:29 --> 00:11:35
the following: all right, the
number four is less than the

275
00:11:35 --> 00:11:42
string three, whereas the
string four, oops, is not

276
00:11:42 --> 00:11:43
less than the string three.


277
00:11:43 --> 00:11:45
And this is a place where
it's comparing strings and

278
00:11:45 --> 00:11:47
numbers in a strange way.


279
00:11:47 --> 00:11:48
So why am I showing you this?


280
00:11:48 --> 00:11:51
Partly to show you that it's
kind of weird, but also to tell

281
00:11:51 --> 00:11:57
you that one of the things you
want to do is exercise what I'm

282
00:11:57 --> 00:12:00
going to call some
type discipline.

283
00:12:00 --> 00:12:05
Meaning, when you write code,
you want to get into the habit

284
00:12:05 --> 00:12:08
of A, checking out operators or
procedures to see what they do

285
00:12:08 --> 00:12:10
under different circumstances,
either check them out or read

286
00:12:10 --> 00:12:14
the specifications of it, and
two, when you write your own

287
00:12:14 --> 00:12:16
code, you want to be
disciplined about what types of

288
00:12:16 --> 00:12:20
arguments or operands
you apply to operators.

289
00:12:20 --> 00:12:22
Because this is something that
could certainly have screwed

290
00:12:22 --> 00:12:25
you up if you didn't realize it
did it, and you need to have

291
00:12:25 --> 00:12:29
that discipline to make sure
it's doing the right thing.

292
00:12:29 --> 00:12:30
OK.


293
00:12:30 --> 00:12:33
One of the other things you're
going to see is that some of

294
00:12:33 --> 00:12:36
the operators have
odd meanings.

295
00:12:36 --> 00:12:37
And again, I think
we looked-- Yup?

296
00:12:37 --> 00:12:40
STUDENT: So, the string A is
less than three, is false

297
00:12:40 --> 00:12:40
because they're comparing
like ASCII values?

298
00:12:40 --> 00:12:45
PROFESSOR JIM ERICSON: Yes.


299
00:12:45 --> 00:12:46
I mean, I'm sorry.


300
00:12:46 --> 00:12:47
The answer is, I don't
know if it's ASCII.

301
00:12:47 --> 00:12:48
John, do you know,
are they doing ASCII

302
00:12:48 --> 00:12:49
encoding inside of here?


303
00:12:49 --> 00:12:51
I'm assuming so.


304
00:12:51 --> 00:12:51
Right.


305
00:12:51 --> 00:12:53
So, in case you didn't
understand what the the

306
00:12:53 --> 00:12:57
question was, basically every
symbol gets translated into a

307
00:12:57 --> 00:13:00
particular encoding, a string
of bit, if you like, inside the

308
00:13:00 --> 00:13:03
machine, there's a particular
one called ASCII, which is, if

309
00:13:03 --> 00:13:05
you like, an ordering of that,
and that's what the machine's

310
00:13:05 --> 00:13:08
actually comparing inside of
here, which is why in under

311
00:13:08 --> 00:13:11
ASCII encoding the numbers are
going to appear after the

312
00:13:11 --> 00:13:14
characters, and you get the
strange kind of thing going on.

313
00:13:14 --> 00:13:15
All right.


314
00:13:15 --> 00:13:16
I want a couple of other
things, just to quickly remind

315
00:13:16 --> 00:13:19
you, and one of them is,
remember, the operators do look

316
00:13:19 --> 00:13:22
at the types, so division, for
example nine divided by five is

317
00:13:22 --> 00:13:26
one, because this is integer
division, that is, it's the

318
00:13:26 --> 00:13:29
largest number of integer
multiples of five to go into

319
00:13:29 --> 00:13:32
nine, and there would be a
remainder associated with

320
00:13:32 --> 00:13:36
it, which is in fact four.


321
00:13:36 --> 00:13:37
And again, you've got to
be careful about how

322
00:13:37 --> 00:13:40
you use the operators.


323
00:13:40 --> 00:13:41
Right, having done that, we
can certainly get to more

324
00:13:41 --> 00:13:45
complicated things, so for
example, suppose I look

325
00:13:45 --> 00:13:47
at that expression.


326
00:13:47 --> 00:13:50
Three plus four times five.


327
00:13:50 --> 00:13:51
All right.


328
00:13:51 --> 00:13:52
Now.


329
00:13:52 --> 00:13:55
There are two possible
values here, I think.

330
00:13:55 --> 00:13:57
One is 23, the other's 35.


331
00:13:57 --> 00:14:03
Because this could be three
plus four, times five, or it

332
00:14:03 --> 00:14:07
could be three, plus
four times five.

333
00:14:07 --> 00:14:08
And of course, you know, when
you look at code it doesn't

334
00:14:08 --> 00:14:09
pause in between them.


335
00:14:09 --> 00:14:10
But what I do?


336
00:14:10 --> 00:14:12
I just separated, do I do the
addition first or do the

337
00:14:12 --> 00:14:14
multiplication first?


338
00:14:14 --> 00:14:15
Anybody know what
happens In this case?

339
00:14:15 --> 00:14:17
Yeah, way up, oh God I'm going
to have a hell of time throwing

340
00:14:17 --> 00:14:18
up there, way up at the back.


341
00:14:18 --> 00:14:25
STUDENT: Standard order of
operations, I guess take

342
00:14:25 --> 00:14:26
the multiplication first,
and add the three.

343
00:14:26 --> 00:14:26
PROFESSOR JIM ERICSON: Right.


344
00:14:26 --> 00:14:27
I'm going to try, if I don't
make it, you know, just get

345
00:14:27 --> 00:14:29
somebody to pass back, whoa!


346
00:14:29 --> 00:14:30
I just hit somebody
in the head.

347
00:14:30 --> 00:14:30
Thank you.


348
00:14:30 --> 00:14:32
Please pass it
back to that guy.

349
00:14:32 --> 00:14:34
If you want candy, sit much
closer down, and that way we

350
00:14:34 --> 00:14:36
can film you as well
as we go along.

351
00:14:36 --> 00:14:36
Right.


352
00:14:36 --> 00:14:39
So the point is, there is
something here called operator

353
00:14:39 --> 00:14:45
precedence, which is
what the gentleman said.

354
00:14:45 --> 00:14:48
I'm not going to say much more
about it, but basically what it

355
00:14:48 --> 00:14:52
says is, with all other things
being equal, things like

356
00:14:52 --> 00:14:57
exponentiation are done before
you do multiplication or

357
00:14:57 --> 00:15:00
division, which are done
before you do things like

358
00:15:00 --> 00:15:02
addition and subtraction.


359
00:15:02 --> 00:15:04
And so, in fact, if I wanted
the other version of it, in

360
00:15:04 --> 00:15:06
fact, if I do this right, it's
going to give me 23 because it

361
00:15:06 --> 00:15:09
does the multiplication first,
if I wanted the other version

362
00:15:09 --> 00:15:12
of it, I need to tell it that,
by using, excuse

363
00:15:12 --> 00:15:14
me, parentheses.


364
00:15:14 --> 00:15:16
And in general, what I
would say is, when in

365
00:15:16 --> 00:15:26
doubt, use parens.


366
00:15:26 --> 00:15:29
OK.


367
00:15:29 --> 00:15:32
Now, that just gives
us expressions.

368
00:15:32 --> 00:15:35
We can start having complex
expressions, you can imagine we

369
00:15:35 --> 00:15:36
can have things are lots of
parens, and all sorts

370
00:15:36 --> 00:15:37
of things in it.


371
00:15:37 --> 00:15:38
Yes, question.


372
00:15:38 --> 00:15:46
STUDENT: What does it mean, the
operator used, when you were

373
00:15:46 --> 00:15:46
calculating the remainder
between nine and five?

374
00:15:46 --> 00:15:46
PROFESSOR JIM ERICSON:
It's the percent sign.

375
00:15:46 --> 00:15:47
If you can't read it, I guess
I'm going to have to blow that

376
00:15:47 --> 00:15:47
font up, aren't I,
next time around.

377
00:15:47 --> 00:15:49
Yeah, it's a percent, so
this percent sign will

378
00:15:49 --> 00:15:52
give you the remainder.


379
00:15:52 --> 00:15:53
OK.


380
00:15:53 --> 00:15:55
Second thing I need to do,
though, is I need to, when

381
00:15:55 --> 00:15:57
I get those values, I
want to hang on to them.

382
00:15:57 --> 00:15:59
I'd like to give them a
name, so I can refer to

383
00:15:59 --> 00:16:00
them in other places.


384
00:16:00 --> 00:16:05
And so we saw that as well, the
last piece we had here is the

385
00:16:05 --> 00:16:15
ability to create variables,
which have their own values,

386
00:16:15 --> 00:16:20
and that's done using an
assignment statement.

387
00:16:20 --> 00:16:24
So in particular, that is
an assignment statement.

388
00:16:24 --> 00:16:28
It says, take the name x and
create a binding for that

389
00:16:28 --> 00:16:31
name to the value of the
sub-expression and in fact

390
00:16:31 --> 00:16:35
to do this, to stress a
point, let's do that.

391
00:16:35 --> 00:16:39
It's not just a number,
it's any expression.

392
00:16:39 --> 00:16:42
What Python will do, is it will
evaluate that expression using

393
00:16:42 --> 00:16:43
the kinds of rules we talked
about, and then it creates a

394
00:16:43 --> 00:16:45
binding for x to that value.


395
00:16:45 --> 00:16:47
And I want to stress this,
we're going to come back to it

396
00:16:47 --> 00:16:50
later on in the term, so the
way I'd like you to think about

397
00:16:50 --> 00:16:53
it for now, is that somewhere
in the machine, there's a

398
00:16:53 --> 00:16:57
big space that contains
all possible values.

399
00:16:57 --> 00:16:57
Right.


400
00:16:57 --> 00:16:59
It's a slight lie, it doesn't
have all possible values,

401
00:16:59 --> 00:17:00
but you get the idea.


402
00:17:00 --> 00:17:01
It has, if you like,
intellectually, all

403
00:17:01 --> 00:17:03
possible values.


404
00:17:03 --> 00:17:07
And when I create a binding,
I'm taking a variable name, in

405
00:17:07 --> 00:17:11
this case x, stored somewhere
in a table, and I'm creating

406
00:17:11 --> 00:17:20
a link or a pointer from
that name to that value.

407
00:17:20 --> 00:17:21
This is a nuance.


408
00:17:21 --> 00:17:23
It's going to make a lot more
sense later on when we

409
00:17:23 --> 00:17:26
introduce mutation into our
language, but I want you to

410
00:17:26 --> 00:17:26
start thinking of it that way.


411
00:17:26 --> 00:17:29
Don't think of it as a specific
box into which we're putting

412
00:17:29 --> 00:17:32
things; think of it as
a link to a value.

413
00:17:32 --> 00:17:37
I could have, for example,
another assignment statement,

414
00:17:37 --> 00:17:45
and that creates a binding from
y into that same value, and one

415
00:17:45 --> 00:17:48
of the things as a conservist I
can do is, I could have a

416
00:17:48 --> 00:17:54
statement like, let z be
bound to the value of x.

417
00:17:54 --> 00:17:55
And I said it
deliberately that way.

418
00:17:55 --> 00:17:58
That statement says, get the
value of x, which is this

419
00:17:58 --> 00:18:05
link, and give z a pointer
to the same place.

420
00:18:05 --> 00:18:08
To the value, not to x.


421
00:18:08 --> 00:18:10
OK, and we'll just plant that
idea, we're going to come back

422
00:18:10 --> 00:18:13
to later on, as we carry on.


423
00:18:13 --> 00:18:14
OK.


424
00:18:14 --> 00:18:17
So if we have variables, one
of the questions we can ask

425
00:18:17 --> 00:18:25
is, what's the type
of the variable.

426
00:18:25 --> 00:18:28
And the answer is, it
inherits it from its value.

427
00:18:28 --> 00:18:30
OK.


428
00:18:30 --> 00:18:35
Yes.


429
00:18:35 --> 00:18:39
So if somewhere in my code, I
have that statement, that

430
00:18:39 --> 00:18:41
assignment statement, x
now is a variable whose

431
00:18:41 --> 00:18:44
value is an integer.


432
00:18:44 --> 00:18:48
Unfortunately, at least in my
mind, in Python, these variable

433
00:18:48 --> 00:18:55
bindings are dynamic, or the
type, rather, is dynamic.

434
00:18:55 --> 00:19:00
Meaning, it changes depending
on what the current value is.

435
00:19:00 --> 00:19:03
Or said a different way, if
somewhere later on in the

436
00:19:03 --> 00:19:11
program I do this, x now
has changed its type

437
00:19:11 --> 00:19:14
from INT to string.


438
00:19:14 --> 00:19:16
Now why should you care?


439
00:19:16 --> 00:19:21
OK, my view is, I
don't like it.

440
00:19:21 --> 00:19:24
Especially in the presence
of operator overload.

441
00:19:24 --> 00:19:26
Because I might have written
some code in which I'm

442
00:19:26 --> 00:19:28
expecting that particular
variable to have

443
00:19:28 --> 00:19:29
an integer value.


444
00:19:29 --> 00:19:32
If somewhere later on in the
code it shifts to string, I

445
00:19:32 --> 00:19:35
might not be manipulating that
and getting actual values out,

446
00:19:35 --> 00:19:37
but not what I wanted, and
it's going to be really hard

447
00:19:37 --> 00:19:39
for me to chase it back.


448
00:19:39 --> 00:19:41
So one of the things I would
like to suggest is that you

449
00:19:41 --> 00:19:46
develop some good style here,
and in particular, don't

450
00:19:46 --> 00:19:52
change types arbitrarily.


451
00:19:52 --> 00:19:59
I can't spell today.


452
00:19:59 --> 00:20:01
Meaning, sometimes you need to
do this, but in general

453
00:20:01 --> 00:20:03
there's-- at least in my view
and I don't, John, would you

454
00:20:03 --> 00:20:04
agree?-- you just don't
want to do this.

455
00:20:04 --> 00:20:05
You don't want to
make those changes.

456
00:20:05 --> 00:20:08
It just leads to
trouble down the road.

457
00:20:08 --> 00:20:10
OK.


458
00:20:10 --> 00:20:12
Now, last thing about
variables, and then we're going

459
00:20:12 --> 00:20:14
to start pushing on this, is
where can you use them?

460
00:20:14 --> 00:20:19
And the answer is, you can
use a variable anywhere

461
00:20:19 --> 00:20:20
you can use the value.


462
00:20:20 --> 00:20:32
So, any place it's legal
to use the value.

463
00:20:32 --> 00:20:35
OK.


464
00:20:35 --> 00:20:36
Now.


465
00:20:36 --> 00:20:39
This is just sort of bringing
us back up to speed and adding

466
00:20:39 --> 00:20:40
a few more details in.


467
00:20:40 --> 00:20:42
What we really want to
do now though is start

468
00:20:42 --> 00:20:44
using this stuff.


469
00:20:44 --> 00:20:46
So, operands.


470
00:20:46 --> 00:20:49
Let us take expressions, get
values out, we can store them

471
00:20:49 --> 00:20:52
away in places, but ultimately
we want to do something with

472
00:20:52 --> 00:20:54
them, so we need to now start
talking about what are the

473
00:20:54 --> 00:20:56
things we can do inside of
Python, or any programming

474
00:20:56 --> 00:20:58
language, to manipulate them.


475
00:20:58 --> 00:21:08
And for that, we're going
to have statements.

476
00:21:08 --> 00:21:13
Statements are basically, if
you want to think about it,

477
00:21:13 --> 00:21:15
legal, and I was about to use
the word expression except

478
00:21:15 --> 00:21:24
I've misused that elsewhere,
so legal commands that

479
00:21:24 --> 00:21:30
Python can interpret.


480
00:21:30 --> 00:21:32
You've already seen
a couple of them.

481
00:21:32 --> 00:21:39
Print, assignment, certainly
two obvious statements, they're

482
00:21:39 --> 00:21:41
commands to do something.


483
00:21:41 --> 00:21:43
Assignment is binding a name to
a value, print is saying put

484
00:21:43 --> 00:21:45
it back out in the screen.


485
00:21:45 --> 00:21:47
Obviously if you have print as
a way of putting things out, we

486
00:21:47 --> 00:21:49
expect to have ways of getting
input in, we're going to see an

487
00:21:49 --> 00:21:50
example that in the second.


488
00:21:50 --> 00:21:52
And as we go through the next
few lectures, we're going to

489
00:21:52 --> 00:21:54
add in more and more
of these statements.

490
00:21:54 --> 00:21:56
But let's look at what we
could do with this, OK?

491
00:21:56 --> 00:21:59
And to do this, I'm going
to use some code that

492
00:21:59 --> 00:22:00
I've already typed in.


493
00:22:00 --> 00:22:01
So I'm hoping you can
read that, and it's

494
00:22:01 --> 00:22:03
also in your handout.


495
00:22:03 --> 00:22:06
This is a little file I
created, all right, and I'm

496
00:22:06 --> 00:22:09
going to start with a sequence
of these things and walk them

497
00:22:09 --> 00:22:12
along, again I invite you to
put comments on that handout

498
00:22:12 --> 00:22:14
so that you can follow
what we're going to do.

499
00:22:14 --> 00:22:15
All right?


500
00:22:15 --> 00:22:16
So let's look at the
first part of this.

501
00:22:16 --> 00:22:19
Right now, this is
just a text file.

502
00:22:19 --> 00:22:19
OK.


503
00:22:19 --> 00:22:21
And I've highlighted in blue
up there one of the pieces

504
00:22:21 --> 00:22:22
I'm going to start with.


505
00:22:22 --> 00:22:23
And what do I have?


506
00:22:23 --> 00:22:25
I have a sequence of commands;
I've got an assignment

507
00:22:25 --> 00:22:27
statement, I've got another
assignment statement, I've got

508
00:22:27 --> 00:22:29
a print statement, I've got an
input statement, which we'll

509
00:22:29 --> 00:22:31
come back to in a second.


510
00:22:31 --> 00:22:34
And I want to basically try
and use these things to

511
00:22:34 --> 00:22:35
do something with them.


512
00:22:35 --> 00:22:38
Second thing I want to note
is, the little hash mark

513
00:22:38 --> 00:22:41
or the pound sign, that's
identifying a comment.

514
00:22:41 --> 00:22:42
So what's a comment?


515
00:22:42 --> 00:22:46
It's words to you, or to the
reader of the code, that are

516
00:22:46 --> 00:22:47
telling you what's going
on inside of this code.

517
00:22:47 --> 00:22:49
OK?


518
00:22:49 --> 00:22:54
Now, these comments, frankly,
are brain-damaged, or

519
00:22:54 --> 00:22:57
computationally challenged
if you prefer.

520
00:22:57 --> 00:23:00
Meaning, why in the world do I
have to tell the reader that

521
00:23:00 --> 00:23:02
I'm binding x to
the value three?

522
00:23:02 --> 00:23:02
All right?


523
00:23:02 --> 00:23:04
I'm putting them in
there to make a point.

524
00:23:04 --> 00:23:08
In general, good programming
style says you put in comments

525
00:23:08 --> 00:23:11
that are going to be valuable
in helping you as a reader

526
00:23:11 --> 00:23:14
understand what's going
on inside of the code.

527
00:23:14 --> 00:23:16
It could be, what's
the intuition behind

528
00:23:16 --> 00:23:17
this piece of code.


529
00:23:17 --> 00:23:19
It could be, preconditions
I want to have on input.

530
00:23:19 --> 00:23:22
It could be, explanations of
specific things you're doing.

531
00:23:22 --> 00:23:25
But you need to have
those comments there.

532
00:23:25 --> 00:23:27
Now, this becomes a little bit
of one of those motherhood and

533
00:23:27 --> 00:23:28
apple pie kinds of lectures.


534
00:23:28 --> 00:23:30
You know, your mother always
told you to eat brussels

535
00:23:30 --> 00:23:32
sprouts because it
was good for you.

536
00:23:32 --> 00:23:34
Well this is a brussels sprouts
comment. everybody goes yeah,

537
00:23:34 --> 00:23:35
yeah, yeah, comments,
of course.

538
00:23:35 --> 00:23:36
Of course we're going
to do comments.

539
00:23:36 --> 00:23:38
And they never do.


540
00:23:38 --> 00:23:40
So my challenge to you, and I
know Professor Guttag can do

541
00:23:40 --> 00:23:44
this, my challenge to you is, a
year from now, come back and

542
00:23:44 --> 00:23:46
look at code you wrote here.


543
00:23:46 --> 00:23:50
Can you still understand what
it was you were trying to do?

544
00:23:50 --> 00:23:52
I don't know, John, if
you'd agree, right?

545
00:23:52 --> 00:23:54
If you can read the code a year
later, even code you wrote

546
00:23:54 --> 00:23:56
yourself, it's a good
sign that you put good

547
00:23:56 --> 00:23:59
comments in, right?


548
00:23:59 --> 00:24:03
Second good piece of style here
is choice of variable names.

549
00:24:03 --> 00:24:05
These are lousy.


550
00:24:05 --> 00:24:06
Deliberately.


551
00:24:06 --> 00:24:06
OK?


552
00:24:06 --> 00:24:09
I'm just using simple things
like x and y and z because I

553
00:24:09 --> 00:24:10
want to make it, just get
through the lecture

554
00:24:10 --> 00:24:11
if you like.


555
00:24:11 --> 00:24:14
But in general, the choice of
variable name is a great way

556
00:24:14 --> 00:24:15
of commenting your code.


557
00:24:15 --> 00:24:19
Use variable names
that make sense.

558
00:24:19 --> 00:24:21
That little problem set
zero that you did.

559
00:24:21 --> 00:24:23
You read in a couple of values,
you probably stored them away.

560
00:24:23 --> 00:24:27
My bet is, you used simple
names like x and y.

561
00:24:27 --> 00:24:29
A much better name would have
been firstname, lastname, as

562
00:24:29 --> 00:24:31
the name of the variable
to tell you what you were

563
00:24:31 --> 00:24:33
trying to capture there.


564
00:24:33 --> 00:24:34
OK.


565
00:24:34 --> 00:24:38
The other piece I want to say
about variable names is, once I

566
00:24:38 --> 00:24:42
have that choice of variable
name, I can use it, but in fact

567
00:24:42 --> 00:24:44
there are a few things that I
can't use in terms

568
00:24:44 --> 00:24:45
of variable names.


569
00:24:45 --> 00:24:58
So, these are an important way
of documenting, but there're

570
00:24:58 --> 00:24:59
some things excluded.


571
00:24:59 --> 00:25:04
And in particular, there are
some key words that Python

572
00:25:04 --> 00:25:07
is going to use that
have to be excluded.

573
00:25:07 --> 00:25:09
Let me highlight that.


574
00:25:09 --> 00:25:10
As I said, right now
that's just text file.

575
00:25:10 --> 00:25:15
I'm going to save this away--
yeah, not that way, I'm going

576
00:25:15 --> 00:25:22
to save this away-- with the
subscript, or the suffix

577
00:25:22 --> 00:25:25
rather, py to make
it a Python file.

578
00:25:25 --> 00:25:27
Yeah, and I know it's already
there but I'm going to do

579
00:25:27 --> 00:25:30
it, and I get some
wonderful colors.

580
00:25:30 --> 00:25:33
But these are important, OK?


581
00:25:33 --> 00:25:34
So notice what I
have up there now.

582
00:25:34 --> 00:25:35
Comments appear in red.


583
00:25:35 --> 00:25:37
I can see those.


584
00:25:37 --> 00:25:39
There's a keyword, which I'm
going to highlight right up

585
00:25:39 --> 00:25:41
here, print, which is in, I
don't know what that

586
00:25:41 --> 00:25:44
color is, orange?


587
00:25:44 --> 00:25:48
There's a function in purple,
there's a string in green,

588
00:25:48 --> 00:25:51
and in black I have the
assignment statements.

589
00:25:51 --> 00:25:53
That print is a keyword.


590
00:25:53 --> 00:25:56
It's a command to Python
to do something.

591
00:25:56 --> 00:26:00
As a consequence, I can't
use it as a variable name.

592
00:26:00 --> 00:26:01
All right, think about
it for a second.

593
00:26:01 --> 00:26:05
If I wanted to use print as a
variable name, how do I get the

594
00:26:05 --> 00:26:09
system to decide gee, do I want
print as a value for something,

595
00:26:09 --> 00:26:11
or do I want print
as a command?

596
00:26:11 --> 00:26:13
So there's a sequence of these
that are blocked out, and I--

597
00:26:13 --> 00:26:16
John, I think there are
what, twenty-eight?

598
00:26:16 --> 00:26:18
Something like that,
TAs, is that right?

599
00:26:18 --> 00:26:20
Twenty-eight keywords
that are blocked?

600
00:26:20 --> 00:26:23
We'll find them
as we go along--

601
00:26:23 --> 00:26:24
OK.


602
00:26:24 --> 00:26:26
Having done this now, I can
simply go ahead and run this,

603
00:26:26 --> 00:26:29
and in fact if I go up here to
run, you'll see I've got both

604
00:26:29 --> 00:26:31
an option to check the module,
though in this case I'm

605
00:26:31 --> 00:26:33
just going to run it.


606
00:26:33 --> 00:26:35
Oh, notice what happened.


607
00:26:35 --> 00:26:37
It ran through that sequence of
instructions, in particular it

608
00:26:37 --> 00:26:41
bound x to the value three, and
then it took x times x, got the

609
00:26:41 --> 00:26:44
value of x multipied by x,
which of course is nine, bound

610
00:26:44 --> 00:26:47
that to the value of x, and
then it printed out the value,

611
00:26:47 --> 00:26:49
and now it's sitting here
waiting for an input.

612
00:26:49 --> 00:26:52
You notice what it did, it
printed out that little, right

613
00:26:52 --> 00:26:54
up here I'd said enter a number
and that's what it's printed

614
00:26:54 --> 00:26:58
out, so I can enter a number
and it prints it out.

615
00:26:58 --> 00:27:00
Great.


616
00:27:00 --> 00:27:01
Let's run it again.


617
00:27:01 --> 00:27:05
Actually for that, I can just
use, if I'm lucky, function F5,

618
00:27:05 --> 00:27:09
which didn't work, so let me
try it again., here we go.

619
00:27:09 --> 00:27:11
We're going to run that module.


620
00:27:11 --> 00:27:14
OK.


621
00:27:14 --> 00:27:17
Whoa.


622
00:27:17 --> 00:27:20
What happened?


623
00:27:20 --> 00:27:20
I said enter a number.


624
00:27:20 --> 00:27:21
I didn't.


625
00:27:21 --> 00:27:21
I gave it a string.


626
00:27:21 --> 00:27:23
And it still took it.


627
00:27:23 --> 00:27:25
And printed it up.


628
00:27:25 --> 00:27:27
Well, this is one of the places
where I want to come back to

629
00:27:27 --> 00:27:29
that highlighting of
what do things do?

630
00:27:29 --> 00:27:33
Even though my statement said
enter a number, in particular,

631
00:27:33 --> 00:27:36
raw input here simply takes in
a set of characters and

632
00:27:36 --> 00:27:38
treats it as a string.


633
00:27:38 --> 00:27:39
And then prints it back out.


634
00:27:39 --> 00:27:42
So if in fact I wanted to make
sure this was a number, I

635
00:27:42 --> 00:27:44
should have done something like
either try and convert it to a

636
00:27:44 --> 00:27:47
number, which of course failed
here, or put in a check

637
00:27:47 --> 00:27:48
to say where it is.


638
00:27:48 --> 00:27:50
So it's a way of reminding you,
I've got to be careful about

639
00:27:50 --> 00:27:53
the types of things
that I put in.

640
00:27:53 --> 00:27:56
OK.


641
00:27:56 --> 00:28:01
This is still boring, so let's
step on the accelerator.

642
00:28:01 --> 00:28:04
What I have now is the
following: I can write

643
00:28:04 --> 00:28:08
expressions, do combinations of
things to get out values, I can

644
00:28:08 --> 00:28:11
store them away, I
can print them up.

645
00:28:11 --> 00:28:13
But literally all I can do at
this stage is write what we

646
00:28:13 --> 00:28:18
would call a straight-line
program, that is, a program in

647
00:28:18 --> 00:28:28
which we execute in which we
execute the sequence of

648
00:28:28 --> 00:28:31
instructions one by one.


649
00:28:31 --> 00:28:34
Simply walk down that list.


650
00:28:34 --> 00:28:34
That's what we just
did there, right?

651
00:28:34 --> 00:28:35
We just walked
through that list.

652
00:28:35 --> 00:28:36
This is boring.


653
00:28:36 --> 00:28:39
In fact, you can do some nice
things to prove what is the

654
00:28:39 --> 00:28:42
class of functions you can
compute with straight-line

655
00:28:42 --> 00:28:44
programs, and what you'd see
if you did that is, it's not

656
00:28:44 --> 00:28:46
particularly interesting.


657
00:28:46 --> 00:28:48
OK.


658
00:28:48 --> 00:28:49
Let's go back and think
about our recipes.

659
00:28:49 --> 00:28:52
What we use as our
motivation here.

660
00:28:52 --> 00:28:55
Even in real recipes, you
have things like, if

661
00:28:55 --> 00:28:59
needed, add sugar.


662
00:28:59 --> 00:29:00
That's a decision.


663
00:29:00 --> 00:29:01
That's a conditional.


664
00:29:01 --> 00:29:02
That's a branch.


665
00:29:02 --> 00:29:04
That says, if something
is true, do something.

666
00:29:04 --> 00:29:06
Otherwise, do
something different.

667
00:29:06 --> 00:29:09
So to really add to
this, we need to have

668
00:29:09 --> 00:29:15
branching programs.


669
00:29:15 --> 00:29:20
What I mean by that is, a
branching program is something

670
00:29:20 --> 00:29:32
that can change the order of
instructions based

671
00:29:32 --> 00:29:36
on some test.


672
00:29:36 --> 00:29:46
And that test is usually
a value of a variable.

673
00:29:46 --> 00:29:47
OK.


674
00:29:47 --> 00:29:49
And these get a whole
lot more interesting.

675
00:29:49 --> 00:29:52
So let's look at a little
example, and this is going to,

676
00:29:52 --> 00:29:55
excuse me, both allow us
introduce the syntax as well as

677
00:29:55 --> 00:29:57
what we want to have as the
flow of control inside of here.

678
00:29:57 --> 00:30:00
So let me go back up here,
and I'm going to comment

679
00:30:00 --> 00:30:10
out that region, and let's
uncomment this region.

680
00:30:10 --> 00:30:12
I want to write a
little piece of code.

681
00:30:12 --> 00:30:14
It's going to print out even or
odd, depending on whether the

682
00:30:14 --> 00:30:19
value I put in, which is x in
this case, is even or odd.

683
00:30:19 --> 00:30:20
Think about that.


684
00:30:20 --> 00:30:24
That says, if this thing has
some particular value, I want

685
00:30:24 --> 00:30:28
to do one thing; otherwise, I
want to do something different.

686
00:30:28 --> 00:30:29
And let's look at
the syntax of this.

687
00:30:29 --> 00:30:31
This is the first of
the conditionals that

688
00:30:31 --> 00:30:36
we're going to see.


689
00:30:36 --> 00:30:38
Notice the format.


690
00:30:38 --> 00:30:39
I'm going to go up there.


691
00:30:39 --> 00:30:41
The first statement right here,
that's just an assignment

692
00:30:41 --> 00:30:43
statement, I'm giving
some value to x.

693
00:30:43 --> 00:30:45
We could make it
something different.

694
00:30:45 --> 00:30:47
And then, notice the
structure here.

695
00:30:47 --> 00:30:48
The next three statements.


696
00:30:48 --> 00:30:50
First of all, IF is a
keyword. which makes sense.

697
00:30:50 --> 00:30:55
It is followed, as you can see
there, by some expression,

698
00:30:55 --> 00:30:56
followed by a colon.


699
00:30:56 --> 00:30:59
And in fact, that colon
is important, so let me

700
00:30:59 --> 00:31:00
stress this over here.


701
00:31:00 --> 00:31:11
The colon is important It's
defining the beginning of

702
00:31:11 --> 00:31:12
a block of instructions.


703
00:31:12 --> 00:31:13
Yes sir.


704
00:31:13 --> 00:31:17
STUDENT: [UNINTELLIGIBLE]


705
00:31:17 --> 00:31:18
PROFESSOR JIM ERICSON:
Based on a test.

706
00:31:18 --> 00:31:21
Usually the value
of a variable.

707
00:31:21 --> 00:31:22
OK, so let me go
back to where I am.

708
00:31:22 --> 00:31:23
I'm looking at that
piece of code.

709
00:31:23 --> 00:31:27
What that colon is saying is,
I'm about to begin a sequence

710
00:31:27 --> 00:31:29
of instructions that I
want to treat as a block.

711
00:31:29 --> 00:31:38
So it identifies a
block of instructions.

712
00:31:38 --> 00:31:43
It's, and in particular, the
colon is the start, and the

713
00:31:43 --> 00:31:48
carriage return is the end.


714
00:31:48 --> 00:31:49
Now what in the world
does that mean?

715
00:31:49 --> 00:31:50
I'm doing a lot of words here,
let me try and say this

716
00:31:50 --> 00:31:51
a little bit better.


717
00:31:51 --> 00:31:54
That code says the following:
the IF says, I've got an

718
00:31:54 --> 00:31:56
expression, I'm going
to evaluate it.

719
00:31:56 --> 00:32:01
If that value is true, I
want to do a set of things.

720
00:32:01 --> 00:32:04
And that set of things is
identified by the sequence of

721
00:32:04 --> 00:32:09
commands that are indented in,
this one right here, following

722
00:32:09 --> 00:32:12
the colon but before I get
back to the same place in

723
00:32:12 --> 00:32:14
terms of the indentation.


724
00:32:14 --> 00:32:19
If that test is not true, I
want to skip this instruction,

725
00:32:19 --> 00:32:23
and there's a second keyword
else, followed by a colon, and

726
00:32:23 --> 00:32:25
that tells me the thing I want
to do in the case

727
00:32:25 --> 00:32:26
that it's false.


728
00:32:26 --> 00:32:36
So in fact if I run this,
ah, and save it, and

729
00:32:36 --> 00:32:37
it prints out odd.


730
00:32:37 --> 00:32:39
So, what happened here?


731
00:32:39 --> 00:32:41
Well, let's look at the code.


732
00:32:41 --> 00:32:43
Right? x is initially
bound to fifteen.

733
00:32:43 --> 00:32:44
I get to the IF.


734
00:32:44 --> 00:32:46
The IF says, evaluate
that next expression.

735
00:32:46 --> 00:32:49
In that next expression, I'm
actually taking advantage of

736
00:32:49 --> 00:32:51
the fact that I'm doing
integer multiplication

737
00:32:51 --> 00:32:52
and division here.


738
00:32:52 --> 00:32:55
Right, that divide is, if x
is an integer and two is an

739
00:32:55 --> 00:32:56
integer, what's it going to do?


740
00:32:56 --> 00:32:59
If x was even, x divided by
two is going to be actually

741
00:32:59 --> 00:33:02
the half of x, right?


742
00:33:02 --> 00:33:04
If x is odd, that integer
division is going to give me

743
00:33:04 --> 00:33:08
the number of multiples of
two, that go into x, plus a

744
00:33:08 --> 00:33:11
remainder, which I'm
going to throw away.

745
00:33:11 --> 00:33:14
In either case, I take that
value and multiply back by two,

746
00:33:14 --> 00:33:18
if it was even I get back the
original number, if it was odd,

747
00:33:18 --> 00:33:20
I'm not going to get back the
original number, so I can

748
00:33:20 --> 00:33:22
just check to see if
they're the same.

749
00:33:22 --> 00:33:24
OK, so a little nuance
that I'm using there.

750
00:33:24 --> 00:33:26
So, the first thing that IF
does, bleah that IF says is,

751
00:33:26 --> 00:33:30
evaluate that expression and if
it's true, do the next thing,

752
00:33:30 --> 00:33:31
the thing after the colon.


753
00:33:31 --> 00:33:34
In this case it's not true,
so it's going to skip down

754
00:33:34 --> 00:33:38
and evaluate the thing
printed up the odd.

755
00:33:38 --> 00:33:38
OK.


756
00:33:38 --> 00:33:38
What-- yes.


757
00:33:38 --> 00:33:41
STUDENT: [INAUDIBLE]


758
00:33:41 --> 00:33:42
PROFESSOR JIM
ERICSON: Thank you.

759
00:33:42 --> 00:33:44
I was hoping somebody
would ask that question.

760
00:33:44 --> 00:33:47
The question was, if you
didn't hear, why do I

761
00:33:47 --> 00:33:49
have two equal signs?


762
00:33:49 --> 00:33:51
It's like I'm doing
this, right?

763
00:33:51 --> 00:33:53
Anybody have a se--%uFFFD why
don't I just use an equal sign?

764
00:33:53 --> 00:33:54
I want to know if something's
equal to something.

765
00:33:54 --> 00:33:55
Yeah.


766
00:33:55 --> 00:33:55
STUDENT: [INAUDIBLE]


767
00:33:55 --> 00:33:58
PROFESSOR JIM
ERICSON: Absolutely.

768
00:33:58 --> 00:34:05
The equal sign is going
to bind-- Nice catch.

769
00:34:05 --> 00:34:06
John, this is so much
fun, throwing candy.

770
00:34:06 --> 00:34:08
I've got to say, we've got to
do this more often-- Right.

771
00:34:08 --> 00:34:09
Let me, let me get
to the point.

772
00:34:09 --> 00:34:10
What does an equal sign do?


773
00:34:10 --> 00:34:11
It is an assignment.


774
00:34:11 --> 00:34:14
It says, take this thing on the
left and use it as a name to

775
00:34:14 --> 00:34:17
bind to the value on the right.


776
00:34:17 --> 00:34:17
It's not what I want here.


777
00:34:17 --> 00:34:20
Having already chosen to use
equal as an assignment, I

778
00:34:20 --> 00:34:23
need something else
to do comparison.

779
00:34:23 --> 00:34:24
And that's why I
use double equals.

780
00:34:24 --> 00:34:27
Those two equal signs are
saying, is this thing equal

781
00:34:27 --> 00:34:31
to, in value, the thing
on the other side?

782
00:34:31 --> 00:34:32
OK.


783
00:34:32 --> 00:34:36
Now, having done that, again I
want to stress this idea and

784
00:34:36 --> 00:34:38
I'm going to write it out one
more time, that there's a

785
00:34:38 --> 00:34:42
particular format here.


786
00:34:42 --> 00:34:47
So we have if, and that is
followed by, I'm going to use

787
00:34:47 --> 00:34:48
angle braces here just to
indicates something goes

788
00:34:48 --> 00:34:54
in here, some test
followed by a colon.

789
00:34:54 --> 00:35:02
That is followed by a
block of instructions.

790
00:35:02 --> 00:35:05
And we have an ELSE, followed
by a colon in some other

791
00:35:05 --> 00:35:17
block of instructions.


792
00:35:17 --> 00:35:20
And I want you to get used to
this, that colon is important,

793
00:35:20 --> 00:35:24
it identifies the start, and
then the set of indented things

794
00:35:24 --> 00:35:27
identify all the things at the
same level, and when we reset

795
00:35:27 --> 00:35:29
back to the previous level,
that's when we go back

796
00:35:29 --> 00:35:31
to where we were.


797
00:35:31 --> 00:35:32
OK.


798
00:35:32 --> 00:35:35
Now, that's a nice simple
little test, let's look at a

799
00:35:35 --> 00:35:39
couple of other examples to get
a sense of what this will do.

800
00:35:39 --> 00:35:47
OK, let me comment this out,
and let's look at this

801
00:35:47 --> 00:35:50
next little piece of code.


802
00:35:50 --> 00:35:51
All right.


803
00:35:51 --> 00:35:53
I'm binding a z to be
some value, and then

804
00:35:53 --> 00:35:55
I'm going to run this.


805
00:35:55 --> 00:36:02
Well, let's just run it
and see what it does.

806
00:36:02 --> 00:36:03
Nothing.


807
00:36:03 --> 00:36:04
OK, so why?


808
00:36:04 --> 00:36:05
Well, let's look at it.


809
00:36:05 --> 00:36:08
I'm doing a test there to say,
if the string x is less than

810
00:36:08 --> 00:36:12
the value of b, and x does not
appear before b as strings,

811
00:36:12 --> 00:36:16
then I was going to do, oh, a
couple of things,

812
00:36:16 --> 00:36:18
because they're at the
same block level.

813
00:36:18 --> 00:36:22
Given that that wasn't
true, it did nothing.

814
00:36:22 --> 00:36:25
Now, wait a minute, you say,
where's the ELSE clause?

815
00:36:25 --> 00:36:26
And the answer is,
I don't need one.

816
00:36:26 --> 00:36:29
All right, if this is purely a
test of, if this is true do

817
00:36:29 --> 00:36:32
this otherwise I don't care, I
don't need the ELSE clause

818
00:36:32 --> 00:36:33
in there to identify it.


819
00:36:33 --> 00:36:35
All right?


820
00:36:35 --> 00:36:38
Second thing I want to look
at is, suppose I compare

821
00:36:38 --> 00:36:39
that the one below it.


822
00:36:39 --> 00:36:45
Oops, that I don't want to do.


823
00:36:45 --> 00:36:53
Comment that out, and
let's uncomment this.

824
00:36:53 --> 00:36:56
Yeah, I've still got a binding
for z and I'm giving it the

825
00:36:56 --> 00:36:59
same test, but notice now I've
got the two same commands but

826
00:36:59 --> 00:37:01
they have different
indentation.

827
00:37:01 --> 00:37:08
In this case, in fact I do
get a different behavior.

828
00:37:08 --> 00:37:10
Why?


829
00:37:10 --> 00:37:14
Because that block identifies a
set of things that I'm going

830
00:37:14 --> 00:37:16
to do if the test is true.


831
00:37:16 --> 00:37:18
If the test was not true,
notice that that last command

832
00:37:18 --> 00:37:21
for print Mon is now back at
the same level as the IF, so

833
00:37:21 --> 00:37:25
what this says is the IF does
the test, having done the test,

834
00:37:25 --> 00:37:27
it decides I'm not going to do
anything in the block below it,

835
00:37:27 --> 00:37:29
I'm going to skip down
therefore to the next

836
00:37:29 --> 00:37:32
instruction at the same level
as the IF, which gets me to the

837
00:37:32 --> 00:37:35
second print statement.


838
00:37:35 --> 00:37:36
OK.


839
00:37:36 --> 00:37:38
So now we're seeing some of
these variations, let's see

840
00:37:38 --> 00:37:39
what else can we do here.


841
00:37:39 --> 00:37:42
So let me just to try something
a little more interesting, and

842
00:37:42 --> 00:37:44
then we'll get to writing
some simple programs.

843
00:37:44 --> 00:37:50
So I'm going to comment those
out, and let's go down to

844
00:37:50 --> 00:37:53
this piece of code,
and uncomment it.

845
00:37:53 --> 00:37:55
Ooh yes, that was brilliant.


846
00:37:55 --> 00:37:59
Let's try this again.


847
00:37:59 --> 00:38:04
And uncomment that, and
uncomment it again.

848
00:38:04 --> 00:38:07
Right, so here's a little piece
of code that's going to print

849
00:38:07 --> 00:38:09
out the smallest
value of three.

850
00:38:09 --> 00:38:13
And notice what this is showing
is that the IFs can be nested.

851
00:38:13 --> 00:38:15
All right, it's so if I looked
at it, it's going to say that

852
00:38:15 --> 00:38:19
IF x is y-- sorry, IF x is less
than y, THEN check to see IF x

853
00:38:19 --> 00:38:22
is less than z, and if that's
true, print out x

854
00:38:22 --> 00:38:23
is the smallest.


855
00:38:23 --> 00:38:26
And notice the structure of it,
if it's not true I'm going

856
00:38:26 --> 00:38:29
to go to that next ELSE, and
print out that z is smallest.

857
00:38:29 --> 00:38:32
If the first test wasn't true,
I'm going to skip that whole

858
00:38:32 --> 00:38:35
block and just go down and
print out that y was smallest.

859
00:38:35 --> 00:38:37
So notice the nesting, I can
flow my way through how

860
00:38:37 --> 00:38:40
those tests are actually
going to take place.

861
00:38:40 --> 00:38:46
All right, so let's run
this and see what happens.

862
00:38:46 --> 00:38:50
Great. y is smallest.


863
00:38:50 --> 00:38:50
OK.


864
00:38:50 --> 00:38:55
Is that code correct?


865
00:38:55 --> 00:38:56
Is that a tentative
hand back there?

866
00:38:56 --> 00:38:57
Yeah.


867
00:38:57 --> 00:39:00
STUDENT: Let me compare
y to [INAUDIBLE]

868
00:39:00 --> 00:39:01
PROFESSOR JIM ERICSON:
Yeah, it's not doing

869
00:39:01 --> 00:39:03
all of the comparisons.


870
00:39:03 --> 00:39:05
All right, and let's just check
this out, because I want to

871
00:39:05 --> 00:39:08
make a point of this, let's go
back and do the following.

872
00:39:08 --> 00:39:18
Let's take y, change it to
thirteen, let's run it, hmm.

873
00:39:18 --> 00:39:20
So what did I miss here?


874
00:39:20 --> 00:39:22
Two important points.


875
00:39:22 --> 00:39:24
First one, when I write a piece
of code, especially code that

876
00:39:24 --> 00:39:28
has branches in it, when I
design test cases for that

877
00:39:28 --> 00:39:32
piece of code, I should try and
have a specific test case for

878
00:39:32 --> 00:39:35
each possible path
through the code.

879
00:39:35 --> 00:39:38
And by just doing that, I just
spotted, there's a bug here.

880
00:39:38 --> 00:39:40
And the bug was in my
thinking, I did not look

881
00:39:40 --> 00:39:41
for all of the tests.


882
00:39:41 --> 00:39:49
So the way I can fix that, is,
let me comment that out, and

883
00:39:49 --> 00:40:03
keep doing that, comment that
out, let's uncomment this,

884
00:40:03 --> 00:40:04
notice the structure here.


885
00:40:04 --> 00:40:06
I now have multiple tests.


886
00:40:06 --> 00:40:08
So actually, let's just run
it and then we'll talk

887
00:40:08 --> 00:40:09
about what it does.


888
00:40:09 --> 00:40:16
I run this, yeah, I have a
syntax error, yes indeed,

889
00:40:16 --> 00:40:20
because I forgot to comment
that one out, all right, and

890
00:40:20 --> 00:40:27
cue, we'll try it again.


891
00:40:27 --> 00:40:29
Ah-ha!


892
00:40:29 --> 00:40:31
And let's quickly look at
the structure of this.

893
00:40:31 --> 00:40:34
This now has, gee, a funny
thing, it says IF x is less

894
00:40:34 --> 00:40:39
than y AND x is less than
z, then do something.

895
00:40:39 --> 00:40:42
And then it has a strange thing
called ELIF, which is simply

896
00:40:42 --> 00:40:45
short for else/if
in a second test.

897
00:40:45 --> 00:40:48
So the way to think about this
in terms of flow is, it starts

898
00:40:48 --> 00:40:51
with that if and it says,
check both of those things.

899
00:40:51 --> 00:40:53
And that fact that both of
those things is the fact

900
00:40:53 --> 00:41:06
that we're using Boolean
combination here.

901
00:41:06 --> 00:41:11
It is to say, we can take any
logical expressions, combine

902
00:41:11 --> 00:41:14
them together with AND, OR,
or NOT to make a complex

903
00:41:14 --> 00:41:17
expression, and use the value
of that expression as my test.

904
00:41:17 --> 00:41:19
And that's literally what I've
done there, right, I've got x

905
00:41:19 --> 00:41:22
less than y, that's a test, it
returns a Boolean, which by the

906
00:41:22 --> 00:41:27
way is the other type, at least
I would include here, it has

907
00:41:27 --> 00:41:33
only two values, which are true
and false, and what that code

908
00:41:33 --> 00:41:38
says, if x is less than y, AND,
logically, whatever I put up

909
00:41:38 --> 00:41:43
there, x is less than z, then
the combination is true, and

910
00:41:43 --> 00:41:44
therefore I'm going
to do something.

911
00:41:44 --> 00:41:48
So AND is if both arguments are
true it's true, OR is if either

912
00:41:48 --> 00:41:50
argument it's true it's true,
NOT is if the argument is not

913
00:41:50 --> 00:41:54
true it's true, and then the
last piece, as I said is, I can

914
00:41:54 --> 00:41:56
now have a sequence of
things I want to do.

915
00:41:56 --> 00:41:59
So if this is true do something
else, otherwise test and see if

916
00:41:59 --> 00:42:01
this is true, do something
else, as many as I like

917
00:42:01 --> 00:42:02
followed by the end.


918
00:42:02 --> 00:42:05
And ELSE, it says, here's
what I want to do.

919
00:42:05 --> 00:42:07
OK.


920
00:42:07 --> 00:42:09
Now.


921
00:42:09 --> 00:42:12
Having added this in, I have
branching instructions.

922
00:42:12 --> 00:42:14
I have simple
branching programs.

923
00:42:14 --> 00:42:16
These are still awfully simple.


924
00:42:16 --> 00:42:16
OK?


925
00:42:16 --> 00:42:20
And they're awfully simple
because, all I can do now, is

926
00:42:20 --> 00:42:24
decide whether to execute some
piece of code or another.

927
00:42:24 --> 00:42:26
Said a different way, in the
case of the straight-line

928
00:42:26 --> 00:42:29
programs, how long would
it take to run a program?

929
00:42:29 --> 00:42:31
Well, basically, however many
instructions I have, because

930
00:42:31 --> 00:42:33
I've got to do each
one in order.

931
00:42:33 --> 00:42:36
With simple branching, how
long is it going to take

932
00:42:36 --> 00:42:38
to run a piece of code?


933
00:42:38 --> 00:42:42
Well at most, I'm going to
execute each instruction once.

934
00:42:42 --> 00:42:42
All right?


935
00:42:42 --> 00:42:43
Because the IFs are saying,
if it's true do this,

936
00:42:43 --> 00:42:46
otherwise skip on it.


937
00:42:46 --> 00:42:49
Therefore, for simple branching
programs, the length of time,

938
00:42:49 --> 00:42:53
the complexity the code, is
what we would call constant.

939
00:42:53 --> 00:42:56
That is, it's at most the
length of the actual

940
00:42:56 --> 00:42:57
number of instructions.


941
00:42:57 --> 00:42:59
It doesn't depend on the input.


942
00:42:59 --> 00:43:00
Real simple programs.


943
00:43:00 --> 00:43:02
Let's take another
simple example.

944
00:43:02 --> 00:43:04
Suppose I want to compute
the average age of

945
00:43:04 --> 00:43:05
all the MIT faculty.


946
00:43:05 --> 00:43:07
There's about a thousand of us.


947
00:43:07 --> 00:43:10
However I do that, I know that
should inherently take more

948
00:43:10 --> 00:43:12
time than it takes to compute
the average age of all

949
00:43:12 --> 00:43:14
the EECS faculty.


950
00:43:14 --> 00:43:16
There's only 125 of us.


951
00:43:16 --> 00:43:19
And that should take more time
than what it takes to compute

952
00:43:19 --> 00:43:21
the average of John's and my
ages, instructors in 600,

953
00:43:21 --> 00:43:23
because there's only two of us.


954
00:43:23 --> 00:43:28
All right, those pieces of code
inherently involved something

955
00:43:28 --> 00:43:31
that does depend on the size of
the input, or on the

956
00:43:31 --> 00:43:32
particular input.


957
00:43:32 --> 00:43:35
And that is a preface to
an idea of computational

958
00:43:35 --> 00:43:36
complexity we're going
to come back to.

959
00:43:36 --> 00:43:38
One of the things we want to
help you do is identify the

960
00:43:38 --> 00:43:41
different classes of
algorithms, what their costs

961
00:43:41 --> 00:43:43
are, and how you can map
problems into the most

962
00:43:43 --> 00:43:47
efficient class to
do the computation.

963
00:43:47 --> 00:43:47
OK.


964
00:43:47 --> 00:43:48
Now.


965
00:43:48 --> 00:43:52
Think for a second about
computing the average

966
00:43:52 --> 00:43:53
age of the faculty.


967
00:43:53 --> 00:43:55
You can already kind of
see what I want to do.

968
00:43:55 --> 00:43:57
I, somehow if, I want to walk
through some sequence of data

969
00:43:57 --> 00:44:01
structures, gathering up or
doing the same thing, adding

970
00:44:01 --> 00:44:03
ages in until I get a total
age and then divide by

971
00:44:03 --> 00:44:04
the number faculty.


972
00:44:04 --> 00:44:07
How do I write a piece
of code for that?

973
00:44:07 --> 00:44:09
Well, let's go back up to
our original starting

974
00:44:09 --> 00:44:10
point of recipes.


975
00:44:10 --> 00:44:13
And I'm sure you don't
remember, but one of the things

976
00:44:13 --> 00:44:18
I had in my recipe, is beat
egg whites until stiff.

977
00:44:18 --> 00:44:19
OK.


978
00:44:19 --> 00:44:21
That until is an
important word.

979
00:44:21 --> 00:44:23
It's actually defining a test.


980
00:44:23 --> 00:44:25
Let me rephrase it into garbled
English that'll lead more

981
00:44:25 --> 00:44:27
naturally into what
I want to do.

982
00:44:27 --> 00:44:31
While the egg whites are
not stiff, beat them.

983
00:44:31 --> 00:44:33
That is a different
kind of structure.

984
00:44:33 --> 00:44:36
It has a test in it, which is
that while, while something

985
00:44:36 --> 00:44:40
is true, do something, but
I want to keep doing it.

986
00:44:40 --> 00:44:45
And so for that, we need
to add one last thing.

987
00:44:45 --> 00:44:49
Which is iteration.


988
00:44:49 --> 00:44:50
Or loops.


989
00:44:50 --> 00:44:52
We're going to see variations
of this, we're going to see a

990
00:44:52 --> 00:44:54
variation of it called
recursion, a little later on,

991
00:44:54 --> 00:44:55
but for now we're just going
to talk about how do

992
00:44:55 --> 00:44:57
we do iterations.


993
00:44:57 --> 00:45:00
And I want to show you an
example of this, to lead

994
00:45:00 --> 00:45:04
to both the syntax,
and to the semantics.

995
00:45:04 --> 00:45:15
And let me comment that out,
and let's go to this one.

996
00:45:15 --> 00:45:15
All right.


997
00:45:15 --> 00:45:17
What does this
piece of code say?

998
00:45:17 --> 00:45:19
Not, what does it do,
but what does it say.

999
00:45:19 --> 00:45:20
Well, the first three
statements are just

1000
00:45:20 --> 00:45:21
assignment statements.


1001
00:45:21 --> 00:45:25
I'm binding x, y, and iters
left to some values.

1002
00:45:25 --> 00:45:27
And then notice the structure,
I got a keyword WHILE, there's

1003
00:45:27 --> 00:45:32
that color identifying it, and
in parentheses I have a test.

1004
00:45:32 --> 00:45:34
I'm expecting the value
that test to be a Boolean.

1005
00:45:34 --> 00:45:36
Followed by a colon.


1006
00:45:36 --> 00:45:38
The colon's identifying
a block of code.

1007
00:45:38 --> 00:45:41
And what this is
saying is, gee.

1008
00:45:41 --> 00:45:43
Check to see if the variable
iters left has a value

1009
00:45:43 --> 00:45:45
greater than zero.


1010
00:45:45 --> 00:45:48
If it does, then execute
each of the instructions

1011
00:45:48 --> 00:45:50
in that block.


1012
00:45:50 --> 00:45:52
So I'm going to have an
assignment of y, I'm going to

1013
00:45:52 --> 00:45:53
have an assignment of iters
left, I've got a comment that I

1014
00:45:53 --> 00:45:56
had borrowed in order to do
some debugging, and then

1015
00:45:56 --> 00:45:57
what do I want it to do?


1016
00:45:57 --> 00:46:01
I want it to go back
around to the test.

1017
00:46:01 --> 00:46:03
Once again, say, is
that test true?

1018
00:46:03 --> 00:46:07
If it is true, execute the
sequence of instructions.

1019
00:46:07 --> 00:46:10
So in fact we can block this
out and see what it does.

1020
00:46:10 --> 00:46:16
If I make a little chart here,
I've got x, y, and iters left.

1021
00:46:16 --> 00:46:19
x starts off as I think I set
it up as, here I can't even

1022
00:46:19 --> 00:46:24
read it, is x is three, y is
zero, iters left is three.

1023
00:46:24 --> 00:46:25
I can hand-simulate it.


1024
00:46:25 --> 00:46:28
It says, is the value of iters
left greater than zero?

1025
00:46:28 --> 00:46:28
Yes it is.


1026
00:46:28 --> 00:46:30
So, execute those
two instructions.

1027
00:46:30 --> 00:46:33
It says, take value of y and
value of x, add them

1028
00:46:33 --> 00:46:36
together, and create that as
the new value of y.

1029
00:46:36 --> 00:46:36
All right.


1030
00:46:36 --> 00:46:38
That's the assigned statement.


1031
00:46:38 --> 00:46:41
It says, take iters left,
subtract one from it, and

1032
00:46:41 --> 00:46:44
bind that as the new
value of iters left.

1033
00:46:44 --> 00:46:46
Having reached the end of
the block, go back up

1034
00:46:46 --> 00:46:48
and check the test.


1035
00:46:48 --> 00:46:49
Is iters left
greater than zero?

1036
00:46:49 --> 00:46:50
Yes it is.


1037
00:46:50 --> 00:46:54
So, evaluate the same sequence
of instructions again. y plus x

1038
00:46:54 --> 00:46:57
is six, that's my new value of
y, two minus one is one, that's

1039
00:46:57 --> 00:47:00
my new value of iters
left, go back up.

1040
00:47:00 --> 00:47:01
Is iters left
greater than zero?

1041
00:47:01 --> 00:47:02
Yes it is.


1042
00:47:02 --> 00:47:07
So once more, thank God I
didn't take 47 as an example, x

1043
00:47:07 --> 00:47:12
plus y, subtract one from iters
left, go back up to the test.

1044
00:47:12 --> 00:47:14
Is iters left's value
greater than zero?

1045
00:47:14 --> 00:47:16
No, it is not.


1046
00:47:16 --> 00:47:20
Therefore, skip the rest of
that block of code and go

1047
00:47:20 --> 00:47:24
to the next instruction,
which is, ah, print out y.

1048
00:47:24 --> 00:47:29
In fact, if we test
this, son of a gun.

1049
00:47:29 --> 00:47:32
Got a simple square procedure,.


1050
00:47:32 --> 00:47:34
Right, It's just squaring an
integer, is what it's doing.

1051
00:47:34 --> 00:47:36
But notice the structure.


1052
00:47:36 --> 00:47:39
Now I have the ability to
create a loop, that is, to

1053
00:47:39 --> 00:47:41
reuse the same pieces
of code over and over

1054
00:47:41 --> 00:47:43
again as I go around.


1055
00:47:43 --> 00:47:47
And this adds, now, a lot
of power to the kinds

1056
00:47:47 --> 00:47:49
of code I can write.


1057
00:47:49 --> 00:47:51
Notice some other things I
want to highlight on this.

1058
00:47:51 --> 00:47:52
All right?


1059
00:47:52 --> 00:47:57
The first one is, that test has
to involve-- shouldn't have to,

1060
00:47:57 --> 00:47:59
but almost always is going to
involve-- the value

1061
00:47:59 --> 00:48:01
of some variable.


1062
00:48:01 --> 00:48:04
What if I don't change the
value of that variable

1063
00:48:04 --> 00:48:05
inside of the code?


1064
00:48:05 --> 00:48:11
Or, another way of saying
it is, what if I did this?

1065
00:48:11 --> 00:48:13
Comment it up.


1066
00:48:13 --> 00:48:15
What happens if I
run this sucker?

1067
00:48:15 --> 00:48:17
STUDENT: [INAUDIBLE]


1068
00:48:17 --> 00:48:19
PROFESSOR JIM ERICSON: Yeah.


1069
00:48:19 --> 00:48:20
It'll go forever.


1070
00:48:20 --> 00:48:21
Absolutely, right?


1071
00:48:21 --> 00:48:24
It's going to loop into an
infinite loop-- I think I can

1072
00:48:24 --> 00:48:27
hit this close, ah, no I can't,
boy what a terrible aim--

1073
00:48:27 --> 00:48:29
All right, what has
[UNINTELLIGIBLE PHRASE]

1074
00:48:29 --> 00:48:32
try again, the point I'm trying
to make here-- thank God we're

1075
00:48:32 --> 00:48:34
at the end of this lecture, my
tongue is falling apart-- the

1076
00:48:34 --> 00:48:38
point I'm trying to make is,
that test needs to involve some

1077
00:48:38 --> 00:48:40
loop variable that is changing.


1078
00:48:40 --> 00:48:42
Otherwise the test is always
going to be true, we're going

1079
00:48:42 --> 00:48:45
to go off here, but this would
loop forever if I did that.

1080
00:48:45 --> 00:48:45
All right.


1081
00:48:45 --> 00:48:49
Second question: or maybe a
better way of saying this, and

1082
00:48:49 --> 00:48:51
the general format you're
likely to see here is, a test

1083
00:48:51 --> 00:48:54
involving a variable name,
which must be initialized

1084
00:48:54 --> 00:48:57
outside of the loop, and which
interior to the loop gets

1085
00:48:57 --> 00:49:00
changed, so that the test
is going to change.

1086
00:49:00 --> 00:49:02
Here's the second question.


1087
00:49:02 --> 00:49:05
What value of inputs, what
values of x will this

1088
00:49:05 --> 00:49:08
run correctly for?


1089
00:49:08 --> 00:49:10
Probably should be
integers, right?

1090
00:49:10 --> 00:49:12
Otherwise, this is going
to be doing something

1091
00:49:12 --> 00:49:16
strange, but all integers?


1092
00:49:16 --> 00:49:18
All right, suppose I do this.


1093
00:49:18 --> 00:49:24
It's my last example.


1094
00:49:24 --> 00:49:26
Yeah, how about that, right?


1095
00:49:26 --> 00:49:29
We knew this was trying to do
squaring, so intellectually we

1096
00:49:29 --> 00:49:31
know we can square -4, it ought
to be 16, but what

1097
00:49:31 --> 00:49:33
happens here?


1098
00:49:33 --> 00:49:34
Double fudge knuckle.


1099
00:49:34 --> 00:49:35
All right?


1100
00:49:35 --> 00:49:39
It's going to run through the
loop, accumulating the answers,

1101
00:49:39 --> 00:49:42
but because I'm subtracting,
it's just going to keep making

1102
00:49:42 --> 00:49:45
x more and more negative as it
goes along, again it's off

1103
00:49:45 --> 00:49:46
into an infinite loop.


1104
00:49:46 --> 00:49:49
Which is a way of reminding you
that I need to think as I write

1105
00:49:49 --> 00:49:52
the code about what are my
expectations from the input,

1106
00:49:52 --> 00:49:54
and how might I enforce them.


1107
00:49:54 --> 00:49:56
In this case, I probably want
to make sure I use absolute

1108
00:49:56 --> 00:49:57
value of x before
I carry it on.

1109
00:49:57 --> 00:50:03
Yes ma'am.


1110
00:50:03 --> 00:50:11
STUDENT: [UNINTELLIGIBLE]


1111
00:50:11 --> 00:50:13
PROFESSOR JIM ERICSON: You're
absolutely right, because I

1112
00:50:13 --> 00:50:16
bind iters left to, um, yeah.


1113
00:50:16 --> 00:50:16
Yes.


1114
00:50:16 --> 00:50:16
Thank you.


1115
00:50:16 --> 00:50:19
Boy, two candy for you.


1116
00:50:19 --> 00:50:20
You caught me making an error.


1117
00:50:20 --> 00:50:21
Yes.


1118
00:50:21 --> 00:50:24
The point is, it's not going to
work, and she caught both of

1119
00:50:24 --> 00:50:26
them, impressive, it's not
going to work because iters

1120
00:50:26 --> 00:50:27
left is already negative, it's
just going to skip the whole

1121
00:50:27 --> 00:50:31
loop, and I'm in trouble, so
thank you for catching that.

1122
00:50:31 --> 00:50:31
All right.


1123
00:50:31 --> 00:50:33
I was going to do one more
example, but I've run you

1124
00:50:33 --> 00:50:34
up to the end of the time.


1125
00:50:34 --> 00:50:36
I'll leave the example on the
handout, it shows you another

1126
00:50:36 --> 00:50:38
version that we'll come
back to next time.

1127
00:50:38 --> 00:50:41
The key thing to notice is,
I now have the ability to

1128
00:50:41 --> 00:50:44
create iterations, which
extends well I can do.

1129
00:50:44 --> 00:50:46
And we'll see you next time.


1130
00:50:46 --> 00:50:48



